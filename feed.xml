<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://fmcgeough.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://fmcgeough.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-28T20:06:47+00:00</updated><id>https://fmcgeough.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Elixir/OTP Supervision</title><link href="https://fmcgeough.github.io/blog/2024/supervision/" rel="alternate" type="text/html" title="Elixir/OTP Supervision"/><published>2024-05-04T08:53:13+00:00</published><updated>2024-05-04T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2024/supervision</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2024/supervision/"><![CDATA[<p>I’ve gotten questions over time about process supervision in Elixir. There’s a lack of clarity for some developers. This is especially true for companies that adopt Elixir. There are probably a few people (if you’re lucky) who know Elixir to some level. But the majority of developers that are onboarded will not know anything about the language.</p> <p>One of the things that I’ve found is the most confusing and usually misused relates to supervision of processes. There are actually plenty of resources available to learn from. I provided some links in the References at the end of this post. A lot of them are probably more insightful than this post. However, I decided it might help some developers new to Elixir if I created some sample code to accompany the description of what’s going on. The idea was that new developers could use this as a basis to play around with the concepts.</p> <p>The code for this blog post is in a github repo at <a href="https://github.com/fmcgeough/elixir-supervision">https://github.com/fmcgeough/elixir-supervision</a>. Assuming you have asdf and the Elixir and Erlang plug-ins installed you can install on your system with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git clone https://github.com/fmcgeough/elixir-supervision
$ asdf install
$ mix deps.get
$ iex -S mix
iex&gt;
</code></pre></div></div> <h2 id="what-is-a-process">What is a Process?</h2> <p>In Elixir (or Erlang) all code runs in a “process”. Processes are isolated from each other. They communicate by sending messages to each other. Elixir’s processes are not O/S processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</p> <p>You can read about processes in the <a href="https://hexdocs.pm/elixir/processes.html">Elixir Documentation</a>.</p> <h2 id="some-general-info-about-processes">Some General Info About Processes</h2> <p>Processes are identified by a pid. When you start a process the system returns a pid. For our purposes a pid can be considered an opaque data structure. A pid is like an address. It allows a process to send a message to another process.</p> <p>If you want to know the inner details of a process then you can read more about it, of course. It’s general structure is described in an OTP header file as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> *  PID layout (internal pids):
 *
 *   |3 3 2 2 2 2 2 2|2 2 2 2 1 1 1 1|1 1 1 1 1 1    |               |
 *   |1 0 9 8 7 6 5 4|3 2 1 0 9 8 7 6|5 4 3 2 1 0 9 8|7 6 5 4 3 2 1 0|
 *   |               |               |               |               |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |n n n n n n n n n n n n n n n n n n n n n n n n n n n n|0 0|1 1|
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 *  n : number
</code></pre></div></div> <p>A process can also be identified in a couple other ways. One of the ways used in the demo code is by name. The name is a unique atom. A module name is an atom and is used in many cases but you can use whatever atom you think makes sense for your application.</p> <p>The test code uses atoms to identify processes. A process name can be converted to a pid by calling: <code class="language-plaintext highlighter-rouge">Process.whereis/1</code>. You can read about that in the <a href="https://hexdocs.pm/elixir/Process.html#whereis/1">Elixir documentation</a>.</p> <h2 id="whats-supervision">What’s Supervision?</h2> <p>A supervisor is a process. It’s job is to be in charge of other processes. These are thought of as its children. A supervisor can start processes. It then uses some facilities built into OTP (linking, monitoring, trapping exits) to allow the supervisor to “know” that something bad happened to one of its children.</p> <p>Any process that isn’t a supervisor falls into the general category “worker”.</p> <p>Supervising workers allows the supervisor to possibly restart the worker if it encounters something unexpected. It ensures that when things are shutdown (whether the entire app or a process tree) that the workers are shutdown in a particular order.</p> <p>Here’s an important quote from “Learn you some Erlang for great good!”</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Supervisors can supervise workers and other supervisors, while workers should never be used
in any position except under another supervisor
</code></pre></div></div> <p>Is this always true? Well… no. There are circumstances where you wouldn’t want to follow this rule. But you should only violate it if you have a very good grasp on supervision and a very good well-understood reason for doing so before you violate it.</p> <h2 id="strategies-for-supervision">Strategies for Supervision</h2> <p>A Supervisor can be written to start its children with different strategies. These are:</p> <ul> <li>:one_for_one</li> <li>:one_for_all</li> <li>:rest_for_one</li> </ul> <p>In Erlang there is another option - :simple_one_for_one. This was in older versions of Elixir but it was deprecated. People that used that strategy before moved to DynamicSupervisor in Elixir.</p> <h3 id="options">Options</h3> <h4 id="one_for_one">:one_for_one</h4> <p>The most common strategy you’re likely to run into. The idea is that each worker (process) that is a child of a supervisor is totally independent. If they die the supervisor should restart just the child that died.</p> <p>This means that you can’t have dependencies between the children. They are independent of each other.</p> <h4 id="one_for_all">:one_for_all</h4> <p>This is the strategy to use if all the children are dependent on each other. What we want in that case is that if any one of the processes dies then all the children should be restarted.</p> <h4 id="rest_for_one">:rest_for_one</h4> <p>This strategy maybe a bit harder to understand but it can be quite useful. This is used if you have one child process that is absolutely vital for all the other children. If it dies then all the children must be restarted. This continues in the order that you supply the children. This is harder to explain then it is to demonstrate. Its demonstration is below.</p> <h2 id="testing">Testing</h2> <p>If you followed the instructions above you should have an iex session open for the project. There’s code in the project that will test each strategy.</p> <p>Each module that has the different types of supervision has the following functions available:</p> <ul> <li>test_kill_all(order) - where order is set to :asc or :desc. This kills the 3 child processes of that supervisor one at a time and shows no result of one child being terminated.</li> <li>test_kill_one_process(process_name) - you can use this if you want to kill any of the 3 child processes</li> <li>show_children/0 - outputs the children names and pid.</li> </ul> <p>When the application starts it starts a number of Supervisors. You can look at the supervision tree using a tool called “observer”. You can start observer from iex. Just type <code class="language-plaintext highlighter-rouge">:observer.start</code>. An app starts that has lots of tabs. Click on Applications and you can see the currently running process trees. See https://www.erlang.org/doc/apps/observer/observer_ug.html for more information.</p> <h3 id="one_for_one-1">:one_for_one</h3> <p>Supervise.Strategies.SuperviseOneForOne starts 3 child workers that use these names:</p> <ul> <li>:one_for_one_worker1</li> <li>:one_for_one_worker2</li> <li>:one_for_one_worker3</li> </ul> <p>There’s a simple picture from the online book “Learn you some Erlang for great good!” that explains what we’ll see.</p> <p><img src="https://learnyousomeerlang.com/static/img/restart-one-for-one.png" alt="one_for_one_supervision"/></p> <p>This shows that if there are 3 worker processes and #2 terminates then #1 and #3 are not impacted.</p> <p>If test_kill_all/1 is called the output shows that only the process being killed terminates.</p> <p>iex&gt; SuperviseOneForOne.test_kill_all(:asc)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; SuperviseOneForOne.test_kill_all(:asc)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START one_for_one_worker1
------  Show children before stop ------
Name: one_for_one_worker3, PID: #PID&lt;0.214.0&gt;
Name: one_for_one_worker2, PID: #PID&lt;0.213.0&gt;
Name: one_for_one_worker1, PID: #PID&lt;0.212.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.212.0&gt;
------  Show children after stop ------
Name: one_for_one_worker3, PID: #PID&lt;0.214.0&gt;
Name: one_for_one_worker2, PID: #PID&lt;0.213.0&gt;
Name: one_for_one_worker1, PID: #PID&lt;0.225.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE one_for_one_worker1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START one_for_one_worker2
------  Show children before stop ------
Name: one_for_one_worker3, PID: #PID&lt;0.214.0&gt;
Name: one_for_one_worker2, PID: #PID&lt;0.213.0&gt;
Name: one_for_one_worker1, PID: #PID&lt;0.225.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.213.0&gt;
------  Show children after stop ------
Name: one_for_one_worker3, PID: #PID&lt;0.214.0&gt;
Name: one_for_one_worker2, PID: #PID&lt;0.226.0&gt;
Name: one_for_one_worker1, PID: #PID&lt;0.225.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE one_for_one_worker2
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START one_for_one_worker3
------  Show children before stop ------
Name: one_for_one_worker3, PID: #PID&lt;0.214.0&gt;
Name: one_for_one_worker2, PID: #PID&lt;0.226.0&gt;
Name: one_for_one_worker1, PID: #PID&lt;0.225.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.214.0&gt;
------  Show children after stop ------
Name: one_for_one_worker3, PID: #PID&lt;0.227.0&gt;
Name: one_for_one_worker2, PID: #PID&lt;0.226.0&gt;
Name: one_for_one_worker1, PID: #PID&lt;0.225.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE one_for_one_worker3
</code></pre></div></div> <h3 id="one_for_all-1">:one_for_all</h3> <p>Supervise.Strategies.SuperviseOneForAll starts 3 child workers:</p> <ul> <li>:one_for_all_worker1</li> <li>:one_for_all_worker2</li> <li>:one_for_all_worker3</li> </ul> <p>There’s a simple picture from “Learn you some Erlang for great good!” that explains what we’ll see.</p> <p><img src="https://learnyousomeerlang.com/static/img/restart-one-for-all.png" alt="one_for_all_supervision"/></p> <p>So, in this case, if process #2 terminates then all the child processes are terminated with it. The Supervisor restarts all 3 processes in order: process #1, process #2, and then process #3.</p> <p>If test_kill_all/1 is called the output shows that every child process terminates when any process terminates.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(1)&gt; SuperviseOneForAll.test_kill_all(:asc)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START one_for_all_worker1
------  Show children before stop ------
Name: one_for_all_worker3, PID: #PID&lt;0.233.0&gt;
Name: one_for_all_worker2, PID: #PID&lt;0.232.0&gt;
Name: one_for_all_worker1, PID: #PID&lt;0.231.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.231.0&gt;
Terminating #PID&lt;0.233.0&gt; with reason :shutdown and state "one_for_all_worker3"
Terminating #PID&lt;0.232.0&gt; with reason :shutdown and state "one_for_all_worker2"
------  Show children after stop ------
Name: one_for_all_worker3, PID: #PID&lt;0.238.0&gt;
Name: one_for_all_worker2, PID: #PID&lt;0.237.0&gt;
Name: one_for_all_worker1, PID: #PID&lt;0.236.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE one_for_all_worker1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START one_for_all_worker2
------  Show children before stop ------
Name: one_for_all_worker3, PID: #PID&lt;0.238.0&gt;
Name: one_for_all_worker2, PID: #PID&lt;0.237.0&gt;
Name: one_for_all_worker1, PID: #PID&lt;0.236.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.237.0&gt;
Terminating #PID&lt;0.238.0&gt; with reason :shutdown and state "one_for_all_worker3"
Terminating #PID&lt;0.236.0&gt; with reason :shutdown and state "one_for_all_worker1"
------  Show children after stop ------
Name: one_for_all_worker3, PID: #PID&lt;0.241.0&gt;
Name: one_for_all_worker2, PID: #PID&lt;0.240.0&gt;
Name: one_for_all_worker1, PID: #PID&lt;0.239.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE one_for_all_worker2
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START one_for_all_worker3
------  Show children before stop ------
Name: one_for_all_worker3, PID: #PID&lt;0.241.0&gt;
Name: one_for_all_worker2, PID: #PID&lt;0.240.0&gt;
Name: one_for_all_worker1, PID: #PID&lt;0.239.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.241.0&gt;
Terminating #PID&lt;0.240.0&gt; with reason :shutdown and state "one_for_all_worker2"
Terminating #PID&lt;0.239.0&gt; with reason :shutdown and state "one_for_all_worker1"
------  Show children after stop ------
Name: one_for_all_worker3, PID: #PID&lt;0.244.0&gt;
Name: one_for_all_worker2, PID: #PID&lt;0.243.0&gt;
Name: one_for_all_worker1, PID: #PID&lt;0.242.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE one_for_all_worker3
</code></pre></div></div> <h3 id="rest_for_one-1">:rest_for_one</h3> <p>Supervise.Strategies.SuperviseRestForOne starts 3 child workers:</p> <ul> <li>:rest_for_one_worker1</li> <li>:rest_for_one_worker2</li> <li>:rest_for_one_worker3</li> </ul> <p>There’s a simple picture from “Learn you some Erlang for great good!” that explains what we’ll see.</p> <p><img src="https://learnyousomeerlang.com/static/img/restart-rest-for-one.png" alt="rest_for_one_supervision"/></p> <p>There are 3 processes running under the supervisor. If process #2 terminates then process #3 is terminated since it started after process #2. Then process #2 is restarted followed by process #3.</p> <p>If test_kill_all/1 is called the output shows different results depending on which child is terminated. If the first child, :rest_for_one_worker1 is terminated then the two other child processes terminate as well. This continues in a chain. If rest_for_one_worker2 is terminates it terminates rest_for_one_worker3 but :rest_for_one_worker1 is still running.</p> <p><code class="language-plaintext highlighter-rouge">iex&gt; SuperviseRestForOne.test_kill_all(:asc)</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SuperviseRestForOne.test_kill_all(:asc)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START rest_for_one_worker1
------  Show children before stop ------
Name: rest_for_one_worker3, PID: #PID&lt;0.229.0&gt;
Name: rest_for_one_worker2, PID: #PID&lt;0.228.0&gt;
Name: rest_for_one_worker1, PID: #PID&lt;0.227.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.227.0&gt;
Terminating #PID&lt;0.229.0&gt; with reason :shutdown and state "rest_for_one_worker3"
Terminating #PID&lt;0.228.0&gt; with reason :shutdown and state "rest_for_one_worker2"
------  Show children after stop ------
Name: rest_for_one_worker3, PID: #PID&lt;0.239.0&gt;
Name: rest_for_one_worker2, PID: #PID&lt;0.238.0&gt;
Name: rest_for_one_worker1, PID: #PID&lt;0.237.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE rest_for_one_worker1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START rest_for_one_worker2
------  Show children before stop ------
Name: rest_for_one_worker3, PID: #PID&lt;0.239.0&gt;
Name: rest_for_one_worker2, PID: #PID&lt;0.238.0&gt;
Name: rest_for_one_worker1, PID: #PID&lt;0.237.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.238.0&gt;
Terminating #PID&lt;0.239.0&gt; with reason :shutdown and state "rest_for_one_worker3"
------  Show children after stop ------
Name: rest_for_one_worker3, PID: #PID&lt;0.241.0&gt;
Name: rest_for_one_worker2, PID: #PID&lt;0.240.0&gt;
Name: rest_for_one_worker1, PID: #PID&lt;0.237.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE rest_for_one_worker2
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START rest_for_one_worker3
------  Show children before stop ------
Name: rest_for_one_worker3, PID: #PID&lt;0.241.0&gt;
Name: rest_for_one_worker2, PID: #PID&lt;0.240.0&gt;
Name: rest_for_one_worker1, PID: #PID&lt;0.237.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.241.0&gt;
------  Show children after stop ------
Name: rest_for_one_worker3, PID: #PID&lt;0.242.0&gt;
Name: rest_for_one_worker2, PID: #PID&lt;0.240.0&gt;
Name: rest_for_one_worker1, PID: #PID&lt;0.237.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE rest_for_one_worker3
</code></pre></div></div> <h3 id="rest_for_one-but-more-interesting">:rest_for_one but more interesting</h3> <p>The :rest_for_one section above showed how workers act if they are children of a Supervisor that uses <code class="language-plaintext highlighter-rouge">:rest_for_one</code> strategy. But you might think that it seemed a bit odd. Would you have a situation where you had 3 workers and the second depended on first and the third depended on second? Maybe.</p> <p>A scenario you might see instead is that a Supervisor has 2 children. The first is a worker and the second is a Supervisor itself. That Supervisor, in turn, would start its own workers.</p> <p>In the tree above Supervise.Strategies.SuperviseLevels is a Supervisor with two children:</p> <ul> <li>:supervise_levels_worker1</li> <li>Supervise.Strategies.SuperviseLevels.ChildSupervisor</li> </ul> <p>Since the rest for one strategy is used by Supervise.Strategies.SuperviseLevels it means that all the child workers under the ChildSupervisor are dependent on :supervise_levels_worker1. If that process terminates the system would terminate the ChildSupervisor which would turn around and terminate all of its workers. Let’s test this manually this time.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; SuperviseLevels.children()
[
  {Supervise.Strategies.SuperviseLevels.ChildSupervisor, #PID&lt;0.221.0&gt;,
   :supervisor, [Supervise.Strategies.SuperviseLevels.ChildSupervisor]},
  {:supervise_levels_worker1, #PID&lt;0.220.0&gt;, :worker,
   [Supervise.Workers.SimpleWorker]}
]
iex(2)&gt; SuperviseLevels.test_kill_one_process(:supervise_levels_worker1)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START supervise_levels_worker1
------  Show children before stop ------
Name: Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor, PID: #PID&lt;0.221.0&gt;
Name: supervise_levels_worker1, PID: #PID&lt;0.220.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.220.0&gt;
Terminating #PID&lt;0.224.0&gt; with reason :shutdown and state "child_supervisor_worker3"
Terminating #PID&lt;0.223.0&gt; with reason :shutdown and state "child_supervisor_worker2"
Terminating #PID&lt;0.222.0&gt; with reason :shutdown and state "child_supervisor_worker1"
------  Show children after stop ------
Name: Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor, PID: #PID&lt;0.229.0&gt;
Name: supervise_levels_worker1, PID: #PID&lt;0.228.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE supervise_levels_worker1
</code></pre></div></div> <p>This shows that if the child that was started first terminates then the second child and all of its workers are terminated. You can see that both pids are new by the end. Does the ChildSupervisor restart its workers in this case?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; ChildSupervisor.children()
[
{:child_supervisor_worker3, #PID&lt;0.232.0&gt;, :worker,
[Supervise.Workers.SimpleWorker]},
{:child_supervisor_worker2, #PID&lt;0.231.0&gt;, :worker,
[Supervise.Workers.SimpleWorker]},
{:child_supervisor_worker1, #PID&lt;0.230.0&gt;, :worker,
[Supervise.Workers.SimpleWorker]}
]
</code></pre></div></div> <p>Yes, it did.</p> <h3 id="dont-kill-a-supervisor">Don’t Kill a Supervisor</h3> <p>Can we kill the ChildSupervisor process. Yeah, of course. But its not a great test. Supervisors don’t have functionality beyond supervising. All of the interesting code lives down in OTP-land. In general, don’t worry about your Supervisor terminating inadvertently.</p> <h2 id="other-supervisor-questions">Other Supervisor Questions</h2> <h3 id="are-restarts-cumulative">Are restarts cumulative?</h3> <p>If a restart occurs for a process that is being supervised does that count as 1 just for itself or is it added to a total for all the processes being supervised? As it turns out, the <code class="language-plaintext highlighter-rouge">max_restarts</code> are cumulative. So if a Supervisor is supervising 4 children and has <code class="language-plaintext highlighter-rouge">max_restarts</code> set to 3 and all 4 children are killed then the Supervisor itself will restart.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Supervise.MaxRestarts.SuperviseOneForOne.test_kill_all()
Before kill, Current Supervisor pid #PID&lt;0.250.0&gt;
Terminating #PID&lt;0.263.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.261.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.262.0&gt; with reason :shutdown and state nil
Elixir.Supervise.MaxRestarts.SuperviseOneForOne is starting
After kill, Current Supervisor pid #PID&lt;0.264.0&gt;
</code></pre></div></div> <p>So because 4 processes restarted in less than 5 seconds the Supervisor was restarted.</p> <h3 id="does-supervisor-restarting-processes-because-of-one_for_all-strategy-count-against-max_restarts">Does Supervisor restarting processes because of one_for_all strategy count against max_restarts?</h3> <p>No. The Supervisor restarting processes because the strategy is set to <code class="language-plaintext highlighter-rouge">:one_for_all</code> doesn’t add up all the children that it restarts and use that to compare against <code class="language-plaintext highlighter-rouge">:max_restarts</code>. The restart count is the child process itself exiting. Not the Supervisor shutting it down because of this.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(1)&gt; Supervise.MaxRestarts.SuperviseOneForAll.test_kill_one()
Before kill, Current Supervisor pid #PID&lt;0.255.0&gt;
Terminating #PID&lt;0.265.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.264.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.263.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.262.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.261.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.260.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.259.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.258.0&gt; with reason :shutdown and state nil
Terminating #PID&lt;0.257.0&gt; with reason :shutdown and state nil
After kill, Current Supervisor pid #PID&lt;0.255.0&gt;
</code></pre></div></div> <h3 id="is-it-greater-than-max_restarts-or-equal-to">Is it greater than max_restarts or equal to?</h3> <p>Greater than. Using the Supervise.MaxRestarts.SuperviseOneForOne which has 4 children we can kill three of its children and the supervisor is not restarted. This is because its max_restarts is set to 3. So 4 children have to be killed for the Supervisor itself to restart.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Supervise.MaxRestarts.SuperviseOneForOne.test_kill_three()
Before kill, Current Supervisor pid #PID&lt;0.239.0&gt;
After kill, Current Supervisor pid #PID&lt;0.239.0&gt;
</code></pre></div></div> <h3 id="what-about-dynamicsupervisor">What About DynamicSupervisor?</h3> <p>A DynamicSupervisor is a separate variation of supervision in Elixir. With a Supervisor you ordinarily start with static children defined. With a DynamicSupervisor you start with no children and add (or remove) them over time. The only strategy available (at the moment) for DynamicSupervisor is <code class="language-plaintext highlighter-rouge">:one_for_one</code>.</p> <p>You can add children to a Supervisor dynamically as well. So… hmmm… why would there be a DynamicSupervisor? One feature that’s in DynamicSupervisor is that you can specify the max children allowed. There are certain use cases where this is very useful.</p> <p>In a DynamicSupervisor there is no ordering between children. In case of a shutdown the children are shutdown concurrently. This can also be quite useful for some use cases.</p> <h3 id="what-are-those-other-processes">What Are Those Other Processes?</h3> <p>If you run the observer after starting up with iex -S mix then you see a tree (there may be more nodes on it but ignore that for now).</p> <p>The SuperviseOneForAll, etc may look okay to you. But what’s Supervise.Supervisor? If you look in application.ex then you can see that’s how the rest of the tree is filled in.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Supervise.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    IO.puts("#{__MODULE__} is starting")

    children = [
      Supervise.Restart.StartupWait,
      Supervise.Strategies.SuperviseOneForOne,
      Supervise.Strategies.SuperviseRestForOne,
      Supervise.Strategies.SuperviseOneForAll,
      Supervise.Strategies.SuperviseLevels,
      Supervise.Types.SuperviseDynamically,
      Supervise.RestartTypes.Permanent,
      Supervise.RestartTypes.Temporary,
      Supervise.RestartTypes.Transient,
      Supervise.MaxRestarts.UsingOneForOne,
      Supervise.MaxRestarts.UsingOneForAll,
      # Supervise.Timeouts.LazySupervisor,
      Supervise.Restart.WithWait
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: Supervise.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
</code></pre></div></div> <p>You can see that Application is a Supervisor as well. It’s naming itself and setting a strategy of :one_for_one. You can read about Application in the Elixir documentation.</p> <p>How is Application started? That’s done via the mix.exs file.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def application do
  [
    extra_applications: [:logger],
    mod: {Supervise.Application, []}
  ]
end
</code></pre></div></div> <p>The mod tells the “system” when you boot up run the start/2 function.</p> <p>If you bring up observer you’ll see some root level processes that are not named and don’t correspond to modules in the test project. These processes are OTP level things. You can learn more if you are interested by reading through the code. It’s available at <a href="https://github.com/erlang/otp/blob/master/lib/kernel/src/application_master.erl">application_master.erl</a>.</p> <h2 id="building-a-supervisor">Building a Supervisor</h2> <p>When you write a Supervisor its got to have a few essential elements. The layout tends to be pretty standard. And it’s quite simple (ordinarily). Let’s start with a bare defmodule.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FirstSupervisor do
end
</code></pre></div></div> <h3 id="use-supervisor">Use Supervisor</h3> <p>The first thing that you’ll do is include a use Supervisor line after the defmodule.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FirstSupervisor do
  use Supervisor

end
</code></pre></div></div> <p>The use is an Elixir Macro. It ends up calling the function <strong>using</strong> in the Supervisor module. This declares that this module implements the @behaviour Supervisor. It declares a childspec/1 function, builds a default childspec:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%{
  id: __MODULE__,
  start: {__MODULE__, :start_link, [init_arg]},
  type: :supervisor
}
</code></pre></div></div> <p>and uses the <a href="https://hexdocs.pm/elixir/1.12/Supervisor.html#child_spec/2">Supervisor.childspec/2</a> function to build the childspec for the Supervisor itself.</p> <h3 id="create-a-start_link1-function">Create a start_link/1 function</h3> <p>There is a <code class="language-plaintext highlighter-rouge">start_link/1</code> function that calls <code class="language-plaintext highlighter-rouge">Supervisor.start_link/3</code>. The first parameter is the module that implements the required Supervisor functionality. The second parameter is the init_arg. This is passed to the init/1 callback that the module must implement. The third parameter is a list that allows only one element to give the Supervisor a name. So, you might see something like: <code class="language-plaintext highlighter-rouge">Supervisor.start_link(MODULE, :ok, [{:name, MODULE}])</code>.</p> <p>There’s also a <code class="language-plaintext highlighter-rouge">start_link/2</code> where the list that contains the name isn’t passed in. If you use this you’ll have to identify the supervisor process by its pid.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FirstSupervisor do
  use Supervisor
  def start_link(_opts) do
    Supervisor.start_link(__MODULE__, :ok, name: __MODULE__)
  end
end
</code></pre></div></div> <h3 id="create-the-init1-callback-function">Create the init/1 callback function</h3> <p>The use Supervisor macro declared that the module implements the @behaviour Supervisor. The behaviour has one required callback - <code class="language-plaintext highlighter-rouge">init/1</code>.</p> <p>The init callback must return <code class="language-plaintext highlighter-rouge">{:ok, {:supervisor.sup_flags(), [:supervisor.child_spec()]}}</code> or <code class="language-plaintext highlighter-rouge">:ignore</code>. What you’ll generally see in code is the last line in the <code class="language-plaintext highlighter-rouge">init/1</code> callback is: <code class="language-plaintext highlighter-rouge">Supervisor.init(children, opts)</code>. That function ensures that the correct data is returned.</p> <p>The call to <code class="language-plaintext highlighter-rouge">Supervisor.init/2</code> takes children and opts (a Keyword list). The children are a list of specs for the worker processes. The available options that can be passed in are:</p> <ul> <li><code class="language-plaintext highlighter-rouge">:strategy</code> - <code class="language-plaintext highlighter-rouge">:one_for_one</code>, <code class="language-plaintext highlighter-rouge">:rest_for_one</code>, <code class="language-plaintext highlighter-rouge">:one_for_all</code> (you can set this to simple_one_for_one but you’ll get a warning that the strategy is deprecated and you should be using DynamicSupervisor instead). If you don’t set a strategy then your app won’t start.</li> <li><code class="language-plaintext highlighter-rouge">:max_restarts</code> - this is optional and defaults to 3. It’s the maximum number of restarts allowed for the children in a time frame. You can set it to 3 or higher. If you try to set it lower then the value is ignored.</li> <li><code class="language-plaintext highlighter-rouge">:max_seconds</code> - this is optional and defaults to 5 (seconds). This is the time frame for the :max_restarts option. You can set this to any positive integer value. If you try zero or a negative value then your app won’t start.</li> </ul> <h2 id="time-limits">Time Limits</h2> <ul> <li>How long can start_link/3 run before there is a problem?</li> <li>How long can init/1 run before there is a problem?</li> </ul> <p>There’s two modules in the project to help test this:</p> <ul> <li>Supervise.Timeouts.LazySupervisor - Supervisor started by Application</li> <li>Supervise.Timeouts.Lazy - Supervisor started by Supervise.Timeouts.LazySupervisor</li> </ul> <p>By default the code is setup where LazySupervisor creates two Lazy processes - :lazy_start_link and :lazy_init. The <code class="language-plaintext highlighter-rouge">:lazy_start_link</code> waits 1 second before calling <code class="language-plaintext highlighter-rouge">Supervisor.start_link/3</code>. The <code class="language-plaintext highlighter-rouge">:lazy_init</code> waits 1 second after the <code class="language-plaintext highlighter-rouge">init/1</code> function is called before proceeding with normal init functionality. When you start the app with iex -S mix you’ll see:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Elixir.Supervise.Timeouts.LazySupervisor is starting
Elixir.Supervise.Timeouts.Lazy.start_link/1 has name lazy_start_link
Elixir.Supervise.Timeouts.Lazy.start_link/1 will call Supervisor.start_link in 1000 ms
Elixir.Supervise.Timeouts.Lazy.init/1 will continue in 0 ms
Elixir.Supervise.Timeouts.Lazy.start_link/1 has name lazy_init
Elixir.Supervise.Timeouts.Lazy.start_link/1 will call Supervisor.start_link in 0 ms
Elixir.Supervise.Timeouts.Lazy.init/1 will continue in 1000 ms
</code></pre></div></div> <p>So this works fine. But how far can this be pushed? Quite a bit, as it turns out. Exit the iex session and edit the lib/supervise/timeouts/lazy_supervisor.ex file and change the children in the <code class="language-plaintext highlighter-rouge">init/1</code> function to:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    children = [
      lazy_spec(name: :lazy_start_link, start_link_delay: 1000),
      lazy_spec(name: :lazy_init, init_delay: 60_000)
    ]
</code></pre></div></div> <p>and you’ll find that works too. Likewise setting the <code class="language-plaintext highlighter-rouge">:start_link_delay</code> to 60_000 works. It’s odd but something to keep in mind.</p> <h2 id="supervision-when-things-go-wrong">Supervision when things go wrong</h2> <h3 id="too-many-restarts">Too many restarts</h3> <p>A Supervisor defines the maximum number of restarts and the maximum time allowed for that number of restarts. It’s a rolling window. If the maximum time allowed is 5 seconds and a worker process terminates after 5 seconds and then doesn’t terminate again until 30 seconds later then the Supervisor has a count of 1 crash.</p> <p>The ChildSupervisor has a function test_restarts(num_restarts). You pass in the integer value (at least 1). The function ensures that number of child processes restarts. The ChildSupervisor has max_restarts: 3, max_seconds: 1. So we expect that until we pass in a number &gt; 3 the ChildSupervisor simply restarts the terminated worker.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(1)&gt; ChildSupervisor.test_restarts(1)
:ok
iex(2)&gt; ChildSupervisor.test_restarts(2)
:ok
iex(3)&gt; ChildSupervisor.test_restarts(3)
:ok
iex(4)&gt; ChildSupervisor.test_restarts(4)
Terminating #PID&lt;0.259.0&gt; with reason :shutdown and state "child_supervisor_worker3"
Terminating #PID&lt;0.257.0&gt; with reason :shutdown and state "child_supervisor_worker2"
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
:ok
iex(5)&gt; ChildSupervisor.show_children()
Name: child_supervisor_worker3, PID: #PID&lt;0.264.0&gt;
Name: child_supervisor_worker2, PID: #PID&lt;0.263.0&gt;
Name: child_supervisor_worker1, PID: #PID&lt;0.262.0&gt;
</code></pre></div></div> <p>This shows that if the workers associated with the ChildSupervisor terminate frequently enough within a timeframe the ChildSupervisor itself shuts down. Since it has it’s own Supervisor - SuperviseLevels - it is restarted and then the workers are restarted as well.</p> <p>Even though the ChildSupervisor has a strategy of :one_for_one if it shuts down because a child terminated and exceeded the thresholds then any other still running children of ChildSupervisor are shutdown. The ChildSupervisor then terminates and it’s restarted.</p> <p>We can demonstrate too many but over a time period where the max_restarts is never exceeded for that period as well. We’ll terminate 3 children, sleep for 2 seconds, then terminate the 3 children again.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; ChildSupervisor.test_restarts(3); Process.sleep(2_000); ChildSupervisor.test_restarts(3)
:ok
</code></pre></div></div> <p>The ChildSupervisor handled that fine. But if the sleep is shortened the ChildSupervisor is restarted.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; ChildSupervisor.test_restarts(3); Process.sleep(500); ChildSupervisor.test_restarts(3)
Terminating #PID&lt;0.291.0&gt; with reason :shutdown and state "child_supervisor_worker3"
Terminating #PID&lt;0.289.0&gt; with reason :shutdown and state "child_supervisor_worker2"
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
</code></pre></div></div> <h3 id="but-what-if-i-did-kill-a-supervisor">But What if I did Kill a Supervisor?</h3> <p>Let’s first do this a smoother way. We can stop a Supervisor with Supervisor.stop/2.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; pid = Process.whereis(ChildSupervisor)
#PID&lt;0.221.0&gt;
iex&gt; Supervisor.stop(pid, :normal)
Terminating #PID&lt;0.224.0&gt; with reason :shutdown and state "child_supervisor_worker3"
Terminating #PID&lt;0.223.0&gt; with reason :shutdown and state "child_supervisor_worker2"
Terminating #PID&lt;0.222.0&gt; with reason :shutdown and state "child_supervisor_worker1"
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
:ok
</code></pre></div></div> <p>You can see this acts just like the case of the worker restarts exceeding thresholds. In this case the ChildSupervisor stops all 3 workers and then stops. The Supervisor of the ChildSupervisor then restarts it.</p> <p><code class="language-plaintext highlighter-rouge">Process.exit/2</code> is a good deal messier:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pid = Process.whereis(ChildSupervisor)
#PID&lt;0.229.0&gt;
iex(5)&gt; Process.exit(pid, :kill)
Terminating #PID&lt;0.233.0&gt; with reason :killed and state "child_supervisor_worker3"
Terminating #PID&lt;0.231.0&gt; with reason :killed and state "child_supervisor_worker2"
Terminating #PID&lt;0.230.0&gt; with reason :killed and state "child_supervisor_worker1"
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
true
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
iex(6)&gt; Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
Terminating #PID&lt;0.220.0&gt; with reason :shutdown and state "supervise_levels_worker1"
Elixir.Supervise.Strategies.SuperviseLevels is starting
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
Terminating #PID&lt;0.242.0&gt; with reason :shutdown and state "supervise_levels_worker1"
Elixir.Supervise.Strategies.SuperviseLevels is starting
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
Terminating #PID&lt;0.245.0&gt; with reason :shutdown and state "supervise_levels_worker1"
Elixir.Supervise.Strategies.SuperviseLevels is starting
Elixir.Supervise.Strategies.SuperviseLevels.ChildSupervisor is starting
Terminating #PID&lt;0.248.0&gt; with reason :shutdown and state "supervise_levels_worker1"
Terminating #PID&lt;0.218.0&gt; with reason :shutdown and state "one_for_all_worker3"
Terminating #PID&lt;0.217.0&gt; with reason :shutdown and state "one_for_all_worker2"
Terminating #PID&lt;0.216.0&gt; with reason :shutdown and state "one_for_all_worker1"
Terminating #PID&lt;0.214.0&gt; with reason :shutdown and state "rest_for_one_worker3"
Terminating #PID&lt;0.213.0&gt; with reason :shutdown and state "rest_for_one_worker2"
Terminating #PID&lt;0.212.0&gt; with reason :shutdown and state "rest_for_one_worker1"
Terminating #PID&lt;0.210.0&gt; with reason :shutdown and state "one_for_one_worker3"
Terminating #PID&lt;0.209.0&gt; with reason :shutdown and state "one_for_one_worker2"
Terminating #PID&lt;0.208.0&gt; with reason :shutdown and state "one_for_one_worker1"

12:55:40.521 [notice] Application supervise exited: shutdown
</code></pre></div></div> <p>And that’s a good reason to not kill a Supervisor process. The entire application was shutdown as the system thrashed a bit. You can see the ChildSupervisor is restarted multiple times. That causes SuperviseLevels to restart multiple times. SuperviseLevels lives under the Application. The bubbling up of these restarts lead to every process in the application being shut down.</p> <h2 id="restart-values">Restart Values</h2> <p>One of the attributes in a child spec is a restart value. There are 3 types and the Supervisor handles them differently:</p> <ul> <li><code class="language-plaintext highlighter-rouge">:permanent</code> - this is the default and it’s what we’ve used to this point for all the workers created. It indicates the Supervisor should always restart this process.</li> <li><code class="language-plaintext highlighter-rouge">:temporary</code> - the child process is never restarted, regardless of the supervision strategy: any termination (even abnormal) is considered successful.</li> <li><code class="language-plaintext highlighter-rouge">:transient</code> - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal, :shutdown, or {:shutdown, term}.</li> </ul> <h3 id="testing-1">Testing</h3> <h4 id="permanent">:permanent</h4> <p>The tests described above all used permanent so there’s no need to run special tests for this restart value.</p> <h4 id="temporary">:temporary</h4> <p>Running the test_kill_all/1 function for Temporary gives us these results:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Temporary.test_kill_all
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START restart_temporary_worker1
------  Show children before stop ------
Name: restart_temporary_worker3, PID: #PID&lt;0.233.0&gt;
Name: restart_temporary_worker2, PID: #PID&lt;0.232.0&gt;
Name: restart_temporary_worker1, PID: #PID&lt;0.231.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.231.0&gt;
------  Show children after stop ------
Name: restart_temporary_worker3, PID: #PID&lt;0.233.0&gt;
Name: restart_temporary_worker2, PID: #PID&lt;0.232.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE restart_temporary_worker1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START restart_temporary_worker2
------  Show children before stop ------
Name: restart_temporary_worker3, PID: #PID&lt;0.233.0&gt;
Name: restart_temporary_worker2, PID: #PID&lt;0.232.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.232.0&gt;
------  Show children after stop ------
Name: restart_temporary_worker3, PID: #PID&lt;0.233.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE restart_temporary_worker2
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START restart_temporary_worker3
------  Show children before stop ------
Name: restart_temporary_worker3, PID: #PID&lt;0.233.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.233.0&gt;
------  Show children after stop ------
&lt;&lt;&lt;&lt;&lt; DONE restart_temporary_worker3
</code></pre></div></div> <p>You can see the Temporary Supervisor loses all of its children as the test loops killing each in turn. They do not restart. Does this kill the Supervisor?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Process.whereis(Temporary)
#PID&lt;0.230.0&gt;
iex&gt; Supervisor.count_children(Temporary)
%{active: 0, specs: 0, supervisors: 0, workers: 0}
</code></pre></div></div> <p>Nope its running. But it has no children now. We can re-add a worker to it if we wish.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Supervisor.start_child(Temporary, SimpleWorker.build_spec(:restart_temporary_worker1, :temporary))
{:ok, #PID&lt;0.257.0&gt;}
iex&gt; Supervisor.count_children(Supervise.RestartTypes.Temporary)
%{active: 1, specs: 1, supervisors: 0, workers: 1}
</code></pre></div></div> <h4 id="transient">:transient</h4> <p>The Transient Supervisor is going to behave like the Permanent Supervisor in the first test. This is because we are terminating the workers abnormally. Since that is the case the Permanent Supervisor restarts the worker.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Transient.test_kill_all()
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START restart_transient_worker1
------  Show children before stop ------
Name: restart_transient_worker3, PID: #PID&lt;0.237.0&gt;
Name: restart_transient_worker2, PID: #PID&lt;0.236.0&gt;
Name: restart_transient_worker1, PID: #PID&lt;0.235.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.235.0&gt;
------  Show children after stop ------
Name: restart_transient_worker3, PID: #PID&lt;0.237.0&gt;
Name: restart_transient_worker2, PID: #PID&lt;0.236.0&gt;
Name: restart_transient_worker1, PID: #PID&lt;0.240.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE restart_transient_worker1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START restart_transient_worker2
------  Show children before stop ------
Name: restart_transient_worker3, PID: #PID&lt;0.237.0&gt;
Name: restart_transient_worker2, PID: #PID&lt;0.236.0&gt;
Name: restart_transient_worker1, PID: #PID&lt;0.240.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.236.0&gt;
------  Show children after stop ------
Name: restart_transient_worker3, PID: #PID&lt;0.237.0&gt;
Name: restart_transient_worker2, PID: #PID&lt;0.241.0&gt;
Name: restart_transient_worker1, PID: #PID&lt;0.240.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE restart_transient_worker2
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; START restart_transient_worker3
------  Show children before stop ------
Name: restart_transient_worker3, PID: #PID&lt;0.237.0&gt;
Name: restart_transient_worker2, PID: #PID&lt;0.241.0&gt;
Name: restart_transient_worker1, PID: #PID&lt;0.240.0&gt;
------  Stopping one child ------
Killing the process #PID&lt;0.237.0&gt;
------  Show children after stop ------
Name: restart_transient_worker3, PID: #PID&lt;0.242.0&gt;
Name: restart_transient_worker2, PID: #PID&lt;0.241.0&gt;
Name: restart_transient_worker1, PID: #PID&lt;0.240.0&gt;
&lt;&lt;&lt;&lt;&lt; DONE restart_transient_worker3
</code></pre></div></div> <p>And the Transient Supervisor remains up and running - with 3 children.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Process.whereis(Transient)
#PID&lt;0.234.0&gt;
iex&gt; Supervisor.count_children(Transient)
%{active: 3, specs: 3, supervisors: 0, workers: 3}
</code></pre></div></div> <h2 id="real-problems">Real Problems</h2> <h3 id="why-cant-i-configure-a-delay-when-worker-is-restarted">Why Can’t I Configure a Delay When Worker is Restarted?</h3> <p>This has come up many times. The problem that people run into is that a worker terminates because of a network connection problem. The developer knows this happens occasionally. They know that if they can just wait a few seconds before a restart then the connection is probably okay. However, there’s no options available that lets the developer configure a Supervisor to add in a restart delay. And if the worker is restarted really quickly then its easy for it to exceed the <code class="language-plaintext highlighter-rouge">:max_retries</code> allowed by its Supervisor. Thus crashing the Supervisor and possibly taking the entire application down.</p> <p>There are a couple of approaches to resolving this issue. One approach to create a Delay module.</p> <p>The basic idea is that in the start_link for the process we want to delay we call into the Delay module. It contains state that can identify whether this is the first time starting this process or a restart. If its a restart then it will delay the process startup.</p> <p>Note: The brod Erlang Kafka library includes its own Supervisor implementation. This has some of the delay restart functionality used with :erlang.send_after.</p> <p>The sample project has a demonstration of this in Supervise.Restart.StartupWait. A new GenServer module - <code class="language-plaintext highlighter-rouge">Supervise.Workers.WaitWorker</code> - calls the <code class="language-plaintext highlighter-rouge">register/1</code> function in StartupWait in its <code class="language-plaintext highlighter-rouge">start_link/1</code> function. This will ensure that a delay occurs before the WaitWorker process can be created.</p> <h2 id="references">References</h2> <ul> <li><a href="https://learnyousomeerlang.com/supervisors">Learn you some Erlang for great good! - Who Supervises the Supervisors?</a></li> <li><a href="https://www.youtube.com/watch?v=Iih3Nrce3_U">Saša Jurić talk on Supervision - Parenting Children</a></li> <li><a href="https://youtu.be/FtZBTUvRt0g?t=1652">Mat Trudel talk on Supervision - A Funny Thing Happened on the way to the Phoenix</a></li> <li><a href="https://hexdocs.pm/elixir/Supervisor.html">Supervisor — Elixir Documentation</a></li> <li><a href="https://hexdocs.pm/elixir/DynamicSupervisor.html">DynamicSupervisor — Elixir Documentation</a></li> </ul>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[Sample code to demonstrate some aspects of Elixir supervision]]></summary></entry><entry><title type="html">Elixir and Dependencies</title><link href="https://fmcgeough.github.io/blog/2024/updating-elixir-dependencies/" rel="alternate" type="text/html" title="Elixir and Dependencies"/><published>2024-02-21T08:53:13+00:00</published><updated>2024-02-21T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2024/updating-elixir-dependencies</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2024/updating-elixir-dependencies/"><![CDATA[<p>One of the ongoing tasks for a development team is to keep the dependencies of apps up to date. The following information are aspects of that work for Elixir language projects. It doesn’t attempt to explain the language itself and assumes you are at least minimally familiar with it. If you are coming to the language for the first time then the <a href="https://elixir-lang.org/">Elixir website</a> has excellent material to learn the basics of the language.</p> <h2 id="elixir-versioning">Elixir Versioning</h2> <p>Each Elixir library or application has a <code class="language-plaintext highlighter-rouge">mix.exs</code> file. This file is used to configure the project. A sample of this is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Demo.MixProject do
  use Mix.Project

  def project do
    [
      app: :demo,
      version: "0.1.0",
      elixir: "~&gt; 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  defp deps do
    [
    ]
  end
end
</code></pre></div></div> <p>As you can see, a <code class="language-plaintext highlighter-rouge">mix.exs</code> file is Elixir code. It defines a module and has the line <code class="language-plaintext highlighter-rouge">use Mix.Project</code> and some functions. <code class="language-plaintext highlighter-rouge">Mix.Project</code> expects that there is a <code class="language-plaintext highlighter-rouge">project/0</code> function that returns a keyword list representing configuration for the project.</p> <p>One of the keys in the sample above is <code class="language-plaintext highlighter-rouge">:version</code>. This defines the version for the project. If you generate a new library <code class="language-plaintext highlighter-rouge">mix new my_library</code> the version is set to <code class="language-plaintext highlighter-rouge">version: "0.1.0"</code>. The version key/value must be present. If you try and remove the version then mix won’t be able to compile the code. You’ll see this error: <code class="language-plaintext highlighter-rouge">** (Mix) Please ensure mix.exs file has the :version in the project definition</code>.</p> <p>Elixir requires versions to be in the format <code class="language-plaintext highlighter-rouge">MAJOR.MINOR.PATCH</code>. Each of these elements is a number. The meaning of these elements are up to the library developer. However, most libraries use <a href="https://semver.org/">Semantic Versioning</a>.</p> <h2 id="libraries-applications">Libraries? Applications?</h2> <p>For Elixir / Erlang libraries and applications can be thought of as the same thing. It’s a named bundle of some functionality with a version. It’s definitely helpful to think about them as the same thing when dealing with versioning and dependencies.</p> <h2 id="semantic-versioning">Semantic Versioning</h2> <p>The <a href="https://semver.org/">Semantic Versioning website</a> has the definitive explanation of semantic versioning. You should visit that site for a full explanation.</p> <p>Important rules for semantic versioning are:</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ul> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backward compatible manner</li> <li>PATCH version when you make backward compatible bug fixes</li> </ul> <p>One additional rule that is important to keep in mind is: “Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable”.</p> <h2 id="hexpm">hex.pm</h2> <p>Hex is a package manager for the BEAM ecosystem; any language that compiles to run on the BEAM VM, such as Elixir and Erlang, can be used to build Hex packages.</p> <p>Hex is an open-source <a href="https://github.com/hexpm/hex">project</a> initiated in early 2014, and continues to evolve under the stewardship of Six Colors AB which was founded in 2018 by Hex’s creator, Eric Meadows-Jönsson. The project provides tasks that integrate with the Elixir mix tool.</p> <p>Hex provides a <a href="https://hex.pm/">website</a> that allows retrieval of libraries and their associated documentation by version number. It allows organizations to setup private package publishing. This means that libraries developed by your organization could be published to hex.pm and only be available for developers that are in your organization.</p> <p>Since Hex is open-source Cloudsmith created their own private hex repository in February 2014. See the <a href="https://cloudsmith.com/blog/worlds-first-private-hex-repository-with-cloudsmith">Cloudsmith blog post</a> for more information on this.</p> <h2 id="specifying-library-dependencies-in-mixexs">Specifying Library Dependencies in mix.exs</h2> <p>You can examine hex.pm to find the current version of a library. One of the keys returned by the <code class="language-plaintext highlighter-rouge">project/0</code> function your mix.exs file is <code class="language-plaintext highlighter-rouge">:deps</code>. This returns a list of dependencies and is generally seen like above: <code class="language-plaintext highlighter-rouge">deps: deps()</code>. That is, the function <code class="language-plaintext highlighter-rouge">deps/0</code> returns the list of dependencies. Setting up the dependency is adding a line to the list in that function. For example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  defp deps do
    [
      {:telemetry, "~&gt; 1.2"}
    ]
</code></pre></div></div> <h2 id="organization-libraries-stored-elsewhere">Organization Libraries Stored “Elsewhere”</h2> <p>Some organizations use github or gitlab to store their organization’s Elixir libraries. Generally those organizations would tag the library code and build releases for their developers.</p>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[Keeping Your Elixir Dependencies Up To Date]]></summary></entry><entry><title type="html">Debugging Elixir in Production</title><link href="https://fmcgeough.github.io/blog/2024/debug-in-production/" rel="alternate" type="text/html" title="Debugging Elixir in Production"/><published>2024-02-19T08:53:13+00:00</published><updated>2024-02-19T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2024/debug-in-production</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2024/debug-in-production/"><![CDATA[<p>Assuming you are making good use of Logging and generating metrics you may still encounter problems in an Elixir allocation that requires more than that in order to understand what is going on and address the problem.</p> <h2 id="observer_cli">observer_cli</h2> <p>You absolutely should include the <a href="https://hex.pm/packages/observer_cli">observer_cli library</a> as a dependency in your project. It’s a wonderful tool and it brings in some other tooling that I’ve found helpful.</p> <p>What is observer_cli?</p> <ul> <li>Based on recon (by the ubiquitous Fred Hebert)</li> <li>It makes it (relatively) easy to view high memory consumption and find the process responsible</li> <li>Good for general identification of issues but may not lead you to the actual underlying cause</li> <li>Checkout https://hexdocs.pm/observer_cli/ for lots of (sort of awkwardly written) documentation about how to use this</li> </ul> <p>The library provides a bare-bones interface that is full of information. To start it open up a remote console:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; :observer_cli.start
</code></pre></div></div> <p>The start function line shows that the code for observer_cli is written in Erlang.</p> <p>Some of what’s available in the text UI:</p> <ul> <li>Process Information <ul> <li>Number Reductions Run</li> <li>Current Function Executing</li> <li>Size of the Message Queue</li> </ul> </li> <li>Memory Information <ul> <li>Total Allocated</li> <li>Memory for ETS</li> <li>Memory for Atoms used in your application</li> <li>Memory used by your application’s processes</li> </ul> </li> <li>Network <ul> <li>Ports in / out</li> <li>Number bytes transferred</li> <li>Memory Used</li> </ul> </li> </ul> <p>There’s a lot there! If you are in the midst of an incident or problem then you might want:</p> <ul> <li>sort by Reductions if you having an issue where the CPU usage is high. Reductions is kind of an archaic term but you can think of it as analogous to CPU usage.</li> <li>examine memory growth. <ul> <li>Are the number of atoms used by your application constantly increasing? This will ultimately cause a crash. You should search your code for cases where you are dynamically allocating atoms (especially as a result of input that you do not have control over).</li> <li>Is ETS usage growing in an unexpected way?</li> <li>Is the amount of memory used by your processes continually increasing? There may be a garbage collection issue that you must address.</li> </ul> </li> </ul> <h2 id="rolling-your-own---finding-high-cpu-processes">Rolling your own - Finding high CPU processes</h2> <p>The observer_cli UI provides the ability to find high CPU processes but you can do so yourself.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Process.list() |&gt; Enum.map(fn pid -&gt;
  info = :erlang.process_info(pid)
  %{
    reductions: info[:reductions],
    name: info[:registered_name],
    current_function: info[:current_function]
  }
end) |&gt; Enum.sort(&amp;(&amp;1[:reductions] &gt;= &amp;2[:reductions])) |&gt; Enum.take(5)
</code></pre></div></div> <p>This finds the 5 processes that have had the most reductions (but it’s over life of the VM).</p> <h2 id="rolling-your-own---get_state">Rolling your Own - get_state</h2> <p>The function <code class="language-plaintext highlighter-rouge">:sys.get_state/1</code> can be used to output a process’ state.</p> <p>You can use this to (safely) get the state that’s associated with a running GenServer. The execution time is slower than if the GenServer itself provided a handle_call to return its state (i.e. don’t put get_state calls in your regular code ordinarily) but sometimes that’s not available (or its a library’s GenServer that you have no control over). If you need to examine a GenServer’s internal state then this is what you use.</p> <p>Note: if a process is really messed up calling <code class="language-plaintext highlighter-rouge">:sys.get_state/1</code> can timeout.</p> <h2 id="rolling-your-own---erlang-memory">Rolling your own - Erlang memory</h2> <p>The function <code class="language-plaintext highlighter-rouge">:erlang.memory/0</code> gives a quick overview of the current state of memory in your application.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; :erlang.memory
[
  total: 36168216,
  processes: 15933632,
  processes_used: 15932480,
  system: 20234584,
  atom: 442553,
  atom_used: 424872,
  binary: 896224,
  code: 8184066,
  ets: 592096
]
</code></pre></div></div> <p>This same information is available in observer_cli. The key/values returned are:</p> <ul> <li>total - The total amount of memory currently allocated. This is the same as the sum of the memory size for processes and system.</li> <li>processes - The total amount of memory currently allocated for the Erlang processes.</li> <li>processes_used - The total amount of memory currently used by the Erlang processes. This is part of the memory presented as processes memory.</li> <li>system - The total amount of memory currently allocated for the VM that is not directly related to any Erlang process.</li> <li>atom - The total amount of memory currently allocated for atoms. Makes up part of system value.</li> <li>atom_used - The total amount of memory currently used for atoms.</li> <li>binary - The total amount of memory currently allocated for binaries. Makes up part of system value.</li> <li>code - The total amount of memory currently allocated for Erlang/Elixir code. Makes up part of system value.</li> <li>ets - The total amount of memory currently allocated for ETS tables. Makes up part of system value.</li> </ul> <p>You can define a simple function to examine memory over a period of time. For example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; analyze_mem = fn(wait_ms) -&gt;
  memory1 = :erlang.memory();
  Process.sleep(wait_ms);
  memory2 = :erlang.memory();
  Enum.map(memory1, fn {key, value1} -&gt; value2 = Keyword.get(memory2, key); {key, value1 - value2} end) |&gt; Map.new() |&gt; Map.put(:wait_ms, "Memory changes after #{wait_ms} milliseconds")
end
</code></pre></div></div> <p>You can use this function to show a memory change over a period of time of interest. For example the call belows shows the memory change after 250 millseconds:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; analyze_mem.(250)
 analyze_mem.(250)
%{
  atom: 0,
  atom_used: 0,
  binary: 296,
  code: 0,
  ets: 0,
  processes: -258080,
  processes_used: -258080,
  system: 296,
  total: -257784,
  wait_ms: "Memory changes after 250 milliseconds"
}
</code></pre></div></div> <h2 id="tracing-function-calls">Tracing Function Calls</h2> <p>There are a few approaches built in to debug function calls in production. The best one I’ve found is <code class="language-plaintext highlighter-rouge">recon</code>. As noted above, the observer_cli library is built on recon. This means that if you include <code class="language-plaintext highlighter-rouge">observer_cli</code> as a dependency you get recon. Here’s some general information on it:</p> <ul> <li>Written by Fred Hebert and wraps :erlang.trace</li> <li>Production safe and basis for observer_cli. Has more than tracing</li> <li>Recon tracer links to the shell</li> <li>Which means…it shuts itself down on shell disconnect (unlike some other tracing which will run forever unless we explicitly stop it)</li> <li>So even if you had network interruption and got kicked out of your session your tracing is going to be turned off</li> <li>Limits total amount of trace info (unlike some more primitive tracing which will output everything….forever)</li> </ul> <p>Here’s an example of a simple trace:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:recon_trace.calls({Map, :get, :return_trace}, 2)
</code></pre></div></div> <p>In the first argument (the tuple <code class="language-plaintext highlighter-rouge">{Map, :get, :return_trace}</code>) its saying “I want to trace any calls to Map.get. Notice that we don’t specify the arity. Either a call to <code class="language-plaintext highlighter-rouge">Map.get/2</code> or <code class="language-plaintext highlighter-rouge">Map.get/3</code> will be traced. The <code class="language-plaintext highlighter-rouge">:return_trace</code> says “I want to get the return value for the function call”. the second parameter is the number of times to trace. A trace of either the call to the function or the return value counts as a trace. So this is saying “I want to see what is passed to Map.get and then I want to see the return value”.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; a_map = %{a: 133, bb: 3243, ccc: 99221}
iex&gt; :recon_trace.calls({Map, :get, :return_trace}, 2)
iex&gt; Map.get(a_map, :bb)
ex(3)&gt; Map.get(a_map, :bb)
3243

16:22:52.750722 &lt;0.1472.0&gt; 'Elixir.Map':get(#{a=&gt;133, bb=&gt;3243, ccc=&gt;99221}, bb)

16:22:52.756306 &lt;0.1472.0&gt; 'Elixir.Map':get/2 --&gt; 3243
Recon tracer rate limit tripped.
</code></pre></div></div> <p>Recon tracing also provides match spec pattern matching. This is a obtuse skill and is explained better in the doc then I could do. Let’s assume we want to do the same thing but this time only trace if the key passed in to <code class="language-plaintext highlighter-rouge">Map.get</code> is <code class="language-plaintext highlighter-rouge">:ccc</code>. We could do this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; match = [{[:_, :"$1"], [{:==, :"$1", :ccc}], [{:return_trace}]}]
[{[:_, :"$1"], [{:==, :"$1", :ccc}], [{:return_trace}]}]
iex&gt;  :recon_trace.calls({Map, :get, match}, 2)
2
iex(6)&gt; Map.get(a_map, :a)
133
iex(7)&gt; Map.get(a_map, :bb)
3243
iex(8)&gt; Map.get(a_map, :ccc)
99221

16:28:03.217740 &lt;0.1472.0&gt; 'Elixir.Map':get(#{a=&gt;133, bb=&gt;3243, ccc=&gt;99221}, ccc)

16:28:03.217830 &lt;0.1472.0&gt; 'Elixir.Map':get/2 --&gt; 99221
Recon tracer rate limit tripped.
</code></pre></div></div> <p>Notice that that the trace did not occur until the pattern was matched. Other calls were not traced.</p> <p>Note: you can only trace public functions.</p> <p>You can also trace functions processes.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pid = Process.whereis(MyProcess)
:recon_trace.calls({MyProcess, :handle_call, :_}, 10, [{pid, :all}])
</code></pre></div></div> <p>This is saying we want to trace any <code class="language-plaintext highlighter-rouge">handle_call</code> functions for a particular process (identified by <code class="language-plaintext highlighter-rouge">pid</code>).</p> <h2 id="other-helpful-things-in-recon">Other Helpful Things in recon</h2> <p>If you have a <code class="language-plaintext highlighter-rouge">pid</code> for a process you are interested in you can use recon to get information about it.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; pid = Process.whereis(MyProcess)
iex&gt; :recon.info(pid)
[
  meta: [
    registered_name: MyProcess,
    dictionary: [
      "$ancestors": [MyProcess.Supervisor, #PID&lt;0.708.0&gt;],
      "$initial_call": {MyProcess, :init, 1}
    ],
    group_leader: #PID&lt;0.707.0&gt;,
    status: :waiting
  ],
  signals: [
    links: [#PID&lt;0.709.0&gt;],
    monitors: [],
    monitored_by: [],
    trap_exit: false
  ],
  location: [
    initial_call: {:proc_lib, :init_p, 5},
    current_stacktrace: [
      {:gen_server, :loop, 7, [file: 'gen_server.erl', line: 394]},
      {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 249]}
    ]
  ],etc. etc.
</code></pre></div></div> <h2 id="references">References</h2> <ul> <li><a href="https://erlang.org/doc/man/sys.html">Erlang :sys module</a></li> <li><a href="http://erlang.org/doc/man/erlang.html#trace-3">Erlang :trace</a></li> <li><a href="https://erlang.org/doc/man/dbg.html#fun2ms-1">Erlang dbg pattern matching</a></li> <li><a href="https://hex.pm/packages/ex2ms">ex2ms - generate pattern matches for Elixir functions</a></li> <li><a href="https://github.com/zhongwencool/observer_cli">observer_cli</a></li> <li><a href="https://hex.pm/packages/recon">recon - what observer_cli is based on</a></li> <li><a href="https://s3.us-east-2.amazonaws.com/ferd.erlang-in-anger/text.v1.1.0.pdf">Erlang in Anger</a></li> </ul>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[Some debugging suggestions specific to Elixir production]]></summary></entry><entry><title type="html">Elixir, Parameter Validation with Ecto</title><link href="https://fmcgeough.github.io/blog/2023/parameter-validation-with-ecto/" rel="alternate" type="text/html" title="Elixir, Parameter Validation with Ecto"/><published>2023-07-31T08:53:13+00:00</published><updated>2023-07-31T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2023/parameter-validation-with-ecto</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2023/parameter-validation-with-ecto/"><![CDATA[<p>Elixir is a language that first appeared in 2012. There is a web framework called Phoenix that is what is primarily used to develop web-based software in Elixir. The Ecto library is used in Elixir to interact with relational databases. However, Ecto can also be used to validate parameters passed to API endpoints. This is a quick example to help you understand how this is done. It assumes you are already at least somewhat familiar with Elixir and the Phoenix framework. The example is just that, an example. It’s not complete. It’s not meant to be an example of production-level code. You can think of this as an intro and getting started type of thing. It’s got enough complexity to get you past some initial hurdles.</p> <h2 id="prerequisites">Prerequisites</h2> <p>The sample code is in a Phoenix framework app generated with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix phx.new --no-assets  --no-dashboard --no-ecto --no-html --no-live --no-mailer --no-tailwind paramz
</code></pre></div></div> <p>Then the Ecto dependency was added to the mix.exs file:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{:ecto, "~&gt; 3.10"}
</code></pre></div></div> <p>It is not necessary to add a dependency on <code class="language-plaintext highlighter-rouge">ecto_sql</code> nor <code class="language-plaintext highlighter-rouge">db_connection</code>. In an actual application where you have a dependency on <code class="language-plaintext highlighter-rouge">ecto_sql</code> it is not necessary to add a dependency on <code class="language-plaintext highlighter-rouge">ecto</code>. The dependency on <code class="language-plaintext highlighter-rouge">ecto_sql</code> brings in the <code class="language-plaintext highlighter-rouge">ecto</code> library.</p> <h2 id="router">Router</h2> <p>For the example code we have a router with two endpoints:</p> <ul> <li>a simple endpoint with parameters in the path</li> <li>a more complex endpoint with parameters in path, a JSON body containing a nested object and a query string.</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ParamzWeb.Router do
  use ParamzWeb, :router

  pipeline :api do
    plug(:accepts, ["json"])
  end

  scope "/api", ParamzWeb do
    pipe_through(:api)

    # Simple request with parameters in path
    get("/:account_id/:user_id/simple", ParamCheckController, :simple)

    # More complex request with parameter in path, a body containing
    # data and allows a query string
    post("/:account_id/complex", ParamCheckController, :complex)
  end
end
</code></pre></div></div> <h2 id="controller-functions">Controller Functions</h2> <p>For both our controller functions the example code just validates the parameters and then sends back 200 and the validated parameters (which have conversions done). If the parameters are invalid the code returns a 400 status code with the error info on the parameters supplied.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ParamzWeb.ParamCheckController do
  use ParamzWeb, :controller

  import ParamzWeb.Params

  alias ParamzWeb.Params.{Complex, Simple}

  def simple(conn, params) do
    params
    |&gt; Simple.validate()
    |&gt; handle_validation_result()
    |&gt; case do
      {:ok, validated_params} -&gt;
        IO.inspect(validated_params, label: "after Params call")
        conn |&gt; put_status(200) |&gt; json(Map.from_struct(validated_params))

      {:error, :invalid_input, error_msg} -&gt;
        conn |&gt; put_status(400) |&gt; json(%{error: "Invalid parameter input. #{error_msg}"})
    end
  end

  def complex(conn, params) do
    params
    |&gt; Complex.validate()
    |&gt; handle_validation_result()
    |&gt; case do
      {:ok, validated_params} -&gt;
        IO.inspect(validated_params, label: "after Params call")
        conn |&gt; put_status(200) |&gt; json(validated_params)

      {:error, :invalid_input, error_msg} -&gt;
        conn |&gt; put_status(400) |&gt; json(%{error: "Invalid parameter input. #{error_msg}"})
    end
  end
end
</code></pre></div></div> <h2 id="parameter-validation-code">Parameter Validation Code</h2> <h3 id="general-utility">General Utility</h3> <p>A simple module to convert a changeset into either {:ok, map()} or {:error, :invalid_input, String.t()}</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Paramz.Utils.LogHelp do
  @moduledoc """
  Utility functions related to logging errors
  """

  alias Ecto.Changeset

  @doc """
  If our app code gets back an error tuple from Ecto where the second
  element is an Ecto.Changeset this function can convert that value
  into a String for logging
  """
  @spec ecto_error(Ecto.Changeset.t()) :: String.t()
  def ecto_error(%Ecto.Changeset{} = changeset) do
    IO.inspect(changeset, label: "changeset errors")

    Changeset.traverse_errors(changeset, fn {msg, opts} -&gt;
      Enum.reduce(opts, msg, fn {key, value}, acc -&gt;
        String.replace(acc, "%{#{key}}", _to_string(value))
      end)
    end)
    |&gt; Enum.reverse()
    |&gt; Enum.map_join(", ", fn {k, msgs} -&gt;
      "#{k}: #{_to_string(msgs)}"
    end)
  end

  def ecto_error(changeset) do
    raise ArgumentError, "unsupported argument: #{inspect(changeset)}"
  end

  defp _to_string(msgs) when is_list(msgs) do
    msgs |&gt; Enum.map_join(", ", &amp;_to_string(&amp;1))
  end

  defp _to_string(msg) when is_binary(msg) do
    String.replace(msg, "\\n", " ")
  end

  defp _to_string(msg) do
    "#{inspect(msg)}"
  end
end
</code></pre></div></div> <h3 id="validation-for-the-simple-endpoint">Validation for the simple endpoint</h3> <p>This endpoint has two parameters in the path. One is the account id which is an integer. The other is the user id which is also an integer.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ParamzWeb.Params.Simple do
  use Ecto.Schema
  import Ecto.Changeset

  @max_int32 (:math.pow(2, 31) - 1) |&gt; round()

  @primary_key false
  embedded_schema do
    field(:account_id, :integer)
    field(:user_id, :integer)
  end

  def validate(attrs) do
    changeset(%__MODULE__{}, attrs)
  end

  def changeset(%__MODULE__{} = struct, attrs \\ %{}) do
    struct
    |&gt; cast(attrs, [:account_id, :user_id])
    |&gt; validate_required([:account_id, :user_id])
    |&gt; validate_number(:account_id, greater_than: 0, less_than_or_equal_to: @max_int32)
    |&gt; validate_number(:user_id, greater_than: 0, less_than_or_equal_to: @max_int32)
  end
end
</code></pre></div></div> <h2 id="doing-validation-for-complex-endpoint">Doing validation for complex endpoint</h2> <p>In this endpoint there’s a parameter in the path - the account id - a body containing JSON with a nested object - and a query parameter.</p> <p>In order to handle nested objects in Ecto validation you can use the embeds_one syntax. This means that every nested object needs its own Ecto.Schema defined and has its own separate changeset functionality.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ParamzWeb.Params.License do
  use Ecto.Schema
  import Ecto.Changeset

  @max_int32 (:math.pow(2, 31) - 1) |&gt; round()

  @primary_key false
  embedded_schema do
    field(:id, :integer)
    field(:type, :string)
  end

  def changeset(struct, attrs) do
    struct
    |&gt; cast(attrs, [:id, :type])
    |&gt; validate_required([:id, :type])
    |&gt; validate_number(:id, greater_than: 0, less_than_or_equal_to: @max_int32)
  end
end

defmodule ParamzWeb.Params.License do
  use Ecto.Schema
  import Ecto.Changeset

  @max_int32 (:math.pow(2, 31) - 1) |&gt; round()

  @primary_key false
  embedded_schema do
    field(:id, :integer)
    field(:type, :string)
  end

  def changeset(struct, attrs) do
    struct
    |&gt; cast(attrs, [:id, :type])
    |&gt; validate_required([:id, :type])
    |&gt; validate_number(:id, greater_than: 0, less_than_or_equal_to: @max_int32)
  end
end

defmodule ParamzWeb.Params.Complex do
  use Ecto.Schema
  import Ecto.Changeset

  alias ParamzWeb.Params.License

  @max_int32 (:math.pow(2, 31) - 1) |&gt; round()
  @allowed_includes ["posts", "pictures"]
  @allowed_includes_str Enum.join(@allowed_includes, ", ")
  @invalid_include_value "invalid include values. Allowed values:"
  @invalid_include_format "invalid include value. Must be list"

  @primary_key false
  embedded_schema do
    field(:account_id, :integer)
    field(:name, :string)
    field(:email, :string)
    field(:include, {:array, :string})
    embeds_one(:license, License)
  end

  def validate(attrs) do
    changeset(%__MODULE__{}, attrs)
  end

  def changeset(struct, attrs) do
    struct
    |&gt; cast(attrs, [:name, :email, :account_id, :include])
    |&gt; cast_embed(:license)
    |&gt; validate_required([:name, :email, :account_id])
    |&gt; validate_number(:account_id, greater_than: 0, less_than_or_equal_to: @max_int32)
    |&gt; validate_include()
  end

  def validate_include(changeset) do
    changeset
    |&gt; get_field(:include)
    |&gt; validate_include_value(changeset)
  end

  defp validate_include_value(nil, changeset), do: changeset

  defp validate_include_value(includes, changeset) when is_list(includes) do
    if Enum.all?(includes, &amp;(&amp;1 in @allowed_includes)) do
      changeset
    else
      add_error(changeset, :include, "#{@invalid_include_value} #{@allowed_includes_str}")
    end
  end

  defp validate_include_value(_includes, changeset) do
    add_error(changeset, :include, @invalid_include_format)
  end
end

defimpl Jason.Encoder, for: ParamzWeb.Params.License do
  def encode(value, opts) do
    value
    |&gt; Map.take([[:id, :type]])
    |&gt; Jason.Encode.map(opts)
  end
end

defimpl Jason.Encoder, for: ParamzWeb.Params.Complex do
  def encode(value, opts) do
    current_value = Map.take(value, [:account_id, :name, :email, :include])

    if value.license do
      Map.put(current_value, :license, Map.take(value.license, [:id, :type]))
    else
      current_value
    end
    |&gt; Jason.Encode.map(opts)
  end
end
</code></pre></div></div> <h2 id="changeset-errors">Changeset Errors</h2> <p>Here’s some simple code to convert changeset errors to a String.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Paramz.Utils.LogHelp do
  @moduledoc """
  Utility functions related to logging errors
  """

  @doc """
  If our app code gets back an error tuple from Ecto where the second
  element is an Ecto.Changeset this function can convert that value
  into a String for logging
  """
  @spec ecto_error(Ecto.Changeset.t()) :: String.t()
  def ecto_error(%Ecto.Changeset{} = changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} -&gt;
      Enum.reduce(opts, msg, fn {key, value}, acc -&gt;
        String.replace(acc, "%{#{key}}", _to_string(value))
      end)
    end)
    |&gt; Enum.reduce("", fn {k, v}, acc -&gt;
      joined_errors = Enum.join(v, "; ")
      "#{acc} #{k}: #{joined_errors}"
    end)
  end

  def ecto_error(changeset) do
    raise ArgumentError, "unsupported argument: #{inspect(changeset)}"
  end

  defp _to_string(val) when is_list(val) do
    Enum.join(val, ",")
  end

  defp _to_string(val), do: to_string(val)
end
</code></pre></div></div> <h2 id="testing">Testing</h2> <h3 id="simple-endpoint---success">Simple Endpoint - Success</h3> <h4 id="client-side">Client side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -s http://localhost:4000/api/1234/90023377/simple

{"account_id":1234,"user_id":90023377}%
</code></pre></div></div> <h4 id="server-side">Server side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] GET /api/1234/90023377/simple
[debug] Processing with ParamzWeb.ParamCheckController.simple/2
  Parameters: %{"account_id" =&gt; "1234", "user_id" =&gt; "90023377"}
  Pipelines: [:api]
after Params call: %ParamzWeb.Params.Simple{account_id: 1234, user_id: 90023377}
[info] Sent 200 in 1ms
</code></pre></div></div> <h3 id="simple-endpoint---bad-parameters-failure">Simple Endpoint - Bad Parameters, Failure</h3> <h4 id="client-side-1">Client side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -s http://localhost:4000/api/1234/90abcdE77/simple

{"error":"Invalid parameter input.  user_id: is invalid"}%
</code></pre></div></div> <h4 id="server-side-1">Server side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] GET /api/1234/90abcdE77/simple
[debug] Processing with ParamzWeb.ParamCheckController.simple/2
  Parameters: %{"account_id" =&gt; "1234", "user_id" =&gt; "90abcdE77"}
  Pipelines: [:api]
[info] Sent 400 in 1ms
</code></pre></div></div> <h3 id="complex-endpoint---success">Complex Endpoint - Success</h3> <h4 id="client-side-2">Client Side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -s -H "Content-Type: application/json" -X POST -d '{
"name": "testing",
"email": "testing@google.com",
"license": {
  "id": "95055",
  "type": "license_reference"
}
}' http://localhost:4000/api/1234/complex\?include\[\]\=posts

{"account_id":1234,"email":"testing@google.com","include":["teams"],"license":{"id":95055,"type":"license_reference"},"name":"testing"}%
</code></pre></div></div> <h4 id="server-side-logging">Server side logging</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] POST /api/1234/complex
debug] Processing with ParamzWeb.ParamCheckController.complex/2
Parameters: %{"account_id" =&gt; "1234", "email" =&gt; "testing@google.com", "include" =&gt; ["posts"], "license" =&gt; %{"id" =&gt; "95055", "type" =&gt; "license_reference"}, "name" =&gt; "testing"}
Pipelines: [:api]
after Params call: %ParamzWeb.Params.Complex{
account_id: 1234,
name: "testing",
email: "testing@google.com",
include: ["posts"],
license: %ParamzWeb.Params.License{id: 95055, type: "license_reference"}
}
[info] Sent 200 in 2ms
</code></pre></div></div> <h3 id="complex-endpoint---bad-parameters-failure">Complex Endpoint - Bad Parameters, Failure</h3> <h4 id="client-side-3">Client Side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -s -H "Content-Type: application/json" -X POST -d '{
"name": "testing",
"email": "testing@google.com",
"license": {
  "type": "license_reference"
}
}' http://localhost:4000/api/1234/complex\?include\[\]\=posts

{"error": "Invalid parameter input. license: %{id: [\"can't be blank\"]}"}
</code></pre></div></div> <h4 id="server-side-2">Server Side</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex(1)&gt; [info] POST /api/1234/complex
changeset errors: #Ecto.Changeset&lt;
  action: nil,
  changes: %{
    account_id: 1234,
    email: "testing@google.com",
    include: ["posts"],
    license: #Ecto.Changeset&lt;
      action: :insert,
      changes: %{type: "license_reference"},
      errors: [id: {"can't be blank", [validation: :required]}],
      data: #ParamzWeb.Params.License&lt;&gt;,
      valid?: false
    &gt;,
    name: "testing"
  },
  errors: [],
  data: #ParamzWeb.Params.Complex&lt;&gt;,
  valid?: false
&gt;
[debug] Processing with ParamzWeb.ParamCheckController.complex/2
  Parameters: %{"account_id" =&gt; "1234", "email" =&gt; "testing@google.com", "include" =&gt; ["posts"], "license" =&gt; %{"type" =&gt; "license_reference"}, "name" =&gt; "testing"}
  Pipelines: [:api]
[info] Sent 400 in 2ms
</code></pre></div></div> <h2 id="the-params-library">The params library</h2> <p>There is a <a href="https://hex.pm/packages/params">params library</a> that wraps Ecto validation. It attempts to reduce boiler-plate code. However, that comes at a cost in giving up control you might need. In addition, there is no active maintainer for the library at the moment. I’d recommend not using this library at the moment.</p>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[Using the Ecto library to validate API Parameters]]></summary></entry><entry><title type="html">Four Thousand Weeks</title><link href="https://fmcgeough.github.io/blog/2023/four-thouand-weeks/" rel="alternate" type="text/html" title="Four Thousand Weeks"/><published>2023-07-31T07:53:13+00:00</published><updated>2023-07-31T07:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2023/four-thouand-weeks</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2023/four-thouand-weeks/"><![CDATA[<p>Notes on the book <a href="https://us.macmillan.com/books/9780374159122/fourthousandweeks">“Four Thousand Weeks: Time Management for Mortals”</a> by Oliver Burkeman. I enjoyed the book. I think it’s worth reading. It’s not your typical time management book (such as Getting Things Done). It’s not focused on making you more efficient at getting through your day. It wants the reader to think about what it is that they actually want to accomplish in the limited lifetime that each of us is gifted.</p> <h2 id="highlights">Highlights</h2> <p>I’ll take notes when I’m reading. If its a Kindle (or the like) then I can highlight as I go. If its a library book then I’ll usually write a couple notes after I finish a large enough portion of a book. I’ll do this with books I buy too. I don’t generally highlight physical books.</p> <p>I don’t like “keeping” books. When I was younger I built up a fairly large collection of books. As it turns out, books are heavy. It’s a pain to move them. So I began giving away my books - either to friends, charity organizations or our local library. There’s a wonderful service called <a href="https://littlefreelibrary.org/">Free Little Library</a>. We have a couple of them in our surrounding neighborhoods and one was done by a woman that is in a bookclub I belong to.</p> <p>The list below is extracted from my book highlights. They may not be direct quotes. Any errors that you find are almost certainly my fault and not the author’s.</p> <ul> <li>The real problem isn’t our limited time. The real problem - or so I hope to convince you - is that we’ve unwittingly inherited, and feel pressured to live by, a troublesome set of ideas about how to use our limited time, all of which are pretty much guaranteed to make things worse.</li> <li>Traditional time management has long held out the implicit promise of “getting on top of everything”, of becoming the master of one’s time. The yearning for this feeling of control over the unfolding hours and days is an old one: back in 1908, in a short book entitled <a href="https://www.gutenberg.org/ebooks/2274">How to Live on 24 Hours a Day - Project Gutenberg link</a>, the English journalist and novelist Arnold Bennett offered scheduling tips to “that innumerable band of souls who are haunted, more or less painfully, by the feeling that the years slip by, and slip by, and slip by, and they have not yet been able to get their lives into proper working order.”</li> <li>Historians call this way of living (in the Middle Ages) “task orientation,” because the rhythms of life emerge organically from the tasks themselves, rather than being lined up against an abstract timeline, the approach that has become second nature to us today.</li> <li>once “time” and “life” had been separated in most people’s minds, time became a thing that you used - and it’s this shift that serves as a precondition for all the uniquely modern ways in which we struggle with time today.</li> <li>(time) stops being the water in which you swim and turns into something you feel you need to dominate or control</li> <li>“One of my teachers told me, “If I think a thought five times, and I’m not learning anything new from it, I don’t think it anymore.”</li> <li>Mumford wrote “Eternity ceased gradually to serve as the measure and focus of human actions.” In its place came the dictatorship of the clock, the schedule, and the Google calendar alert.</li> <li>instead of clearing the decks, declining to clear the decks, focusing instead on what’s truly of greatest consequence while tolerating the discomfort of knowing that, as you do so, the decks will be filling up further, with emails and errands and other to-dos, many of which you may never get around to at all.</li> <li>smoothness, as it turns out, is a dubious virtue, since it’s often the unsmoothed textures of life that make it liveable, helping nurture the relationships that are crucial for mental and physical health, and for reslience of our communities.</li> <li>when you render the process more convenient, you drain it of its meaning</li> <li>the original Latin word for decide, decidere, means “to cut off”, as in slicing away alternatives; it’s a close cousin of words like “homicide” and “suicide”</li> <li>Become a Better Procrastinator</li> <li>By the end of your life, you’ll have gotten around to doing virtually none of the things you theoretically could have done</li> <li>The real measure of any time management technique is whether or not it helps you neglect the right things</li> <li>pay yourself first when it comes to time. <a href="https://jessicaabel.com/">Creative Career Building for Artists &amp; Writers - Jessica Abel</a></li> <li>the only way to be sure (anything) will happen is to do some of it today, no matter how little, and no matter how many other things may be begging for your attention.</li> <li>limit your work in progress</li> <li>resist the allure of middling priorities - make a list of the top 25 things you want out of life and order them from most important to least. Then organize your time around the top 5. Actively avoid every other item on the list.</li> <li>“you need to learn how to say no to things you do want to do, with the recognition that you have only one life” – Elizabeth Gilbert</li> <li>“We invariably prefer indecision over committing ourselves to a single path” - Henri Bergson</li> <li>psychologist Timothy Wilson “we’re capable of consciously attending to about 0.0004 percent of the information bombarding our brains at any given moment”. In 11 studies, we found that participants typically did not enjoy spending 6 to 15 minutes in a room by themselves with nothing to do but think, that they enjoyed doing mundane external activities much more, and that many preferred to administer electric shocks to themselves instead of being left alone with their thoughts.</li> <li>“Attention is the beginning of devotion” - poet Mary Oliver</li> <li>“We are distracted from distraction by distraction” - T S Eliot</li> </ul> <h2 id="recommendations-from-book">Recommendations From Book</h2> <p>These were books or web articles referenced in the book. I found all of them interesting.</p> <ul> <li>Meditation for fidgety skeptics : a 10% happier how-to book</li> <li>The Path of Least Resistance - Robert Fritz]</li> <li>The Miracle of Morning Pages - Julia Cameron]</li> <li>Death: The End of Self-Improvement - Joan Tollifson]</li> <li>Marilynne Robinson’s “joyless urgency” (The Givenness of Things)</li> <li>Personal Kanban by Jim Benson and Tonianne DeMaria Barry</li> </ul> <h2 id="links">Links</h2> <ul> <li><a href="https://www.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator">Inside the mind of a master procrastinator</a></li> <li><a href="https://www.tenpercent.com/podcast-episode/oliver-burkeman-456">#456. Time Management for Mortals | Oliver Burkeman — Ten Percent Happier</a></li> </ul>]]></content><author><name></name></author><category term="reading"/><category term="reading"/><summary type="html"><![CDATA[Notes on the book Four Thousand Weeks, Time Management for Mortals]]></summary></entry><entry><title type="html">Elixir, Programming Puzzles and Sorting Arrays</title><link href="https://fmcgeough.github.io/blog/2019/contiguous-sort-elixir/" rel="alternate" type="text/html" title="Elixir, Programming Puzzles and Sorting Arrays"/><published>2019-12-31T07:53:13+00:00</published><updated>2019-12-31T07:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2019/contiguous-sort-elixir</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2019/contiguous-sort-elixir/"><![CDATA[<p>There are a number of programming puzzle sites that are worthwhile tools for learning a language, brushing up on your skills or just exploring how other people might solve problems differently than you. I think this is all good. I’ve found it especially helpful in learning a new language. One of the interesting things about trying to solve some of these puzzles with a language like Elixir is that you have to work through the problem in a different way then you would in a language like “C” or Java. Arrays and sorting are common problems where you’d index into an Array with those languages but you want to avoid that in Elixir since you’re dealing with Lists and iterating into a List gets expensive. Here’s an example of a problem where I solved it a different way.</p> <p>Say you’re given the problem of determining if it’s possible to sort an array of integers by reversing one of the array’s contiguous subarrays. So, for example, if you are given the input: <code class="language-plaintext highlighter-rouge">[-1, 5, 4, 3, 2, 8]</code> you can reverse the subarray <code class="language-plaintext highlighter-rouge">[5, 4, 3, 2]</code> and the entire array would end up sorted. But, for the input <code class="language-plaintext highlighter-rouge">[-1, 5, 4, 3, 2, -5]</code> there is no subarray that can be reversed and end up with a sorted array. The output from your function should just be true (a subarray exists that can be reversed to provide sorted array) or false (no such subarray exists). Additional constraints are that if there are any duplicates in the input then the function should return false.</p> <p>If you take a step back from the problem then you realize that in order for the function to return true the input has to consist of a subarray of 0..n ascending elements, then a subarray of 0..n descending elements (where the lowest number of the subarray is &gt; then the highest number of the first subarray) and then a subarray of 0..n ascending elements again (where the lowest number of the last subarray is &gt; the highest number in the descending subarray).</p> <p>In the example, <code class="language-plaintext highlighter-rouge">[-1, 5, 4, 3, 2, 8]</code> the subarrays that need to be identified are <code class="language-plaintext highlighter-rouge">[-1]</code> and <code class="language-plaintext highlighter-rouge">[5, 4, 3, 2]</code> and <code class="language-plaintext highlighter-rouge">[8]</code>. Since -1 is &lt; 2 (the last - lowest - element in subarray2) and since 5 is &lt; 8 (5 is the highest element in subarray 2) then the function should respond “true”.</p> <p>Okay, its hopefully clear that those are the 3 subarrays for this input but what questions do we need to answer to figure out whether reversing that 2nd subarray will leave the array sorted? Starting from the first couple elements of the list [-1, 5] we know that 5 &gt; -1 so 1) we know that we have an ascending subarray consisting of at least -1 and possibly 5. But whether 5 is part of the ascending subarray depends on the next element. Since the next element is 4 it means that 5 is the first element in our descending subarray. We’d keep traversing elements in the list after 4 until we find one that is greater than the element that proceeded it. That’s how we get to [8] as the last subarray.</p> <p>Now, since the 2nd subarray was in descending order and since the 3rd subarray ascends (and stops in this case) with 8 and 8 is greater than our first element in the descending subarray we “know” that this array can be sorted by reversing that descending subarray.</p> <p>The data that it appears that we need to proceed thru the list and make a determination is: 1) what’s the current status (:leading_ascending, :descending, :trailing_ascending); 2) what’s the maximum (last) number in subarray1 (this allows us to check for whether any number in the 2nd subarray is less than max_subarray1); 3) what’s the maximum (first) number in subarray2 (this allows us to check for whether the number that starts the 3rd ascending subarray is less than max_subarray2). Since we may or may not have an initial ascending section the value of max_subarray1 can be nil.</p> <p>If we put all the logic into our state module then the driver to determine true/false becomes pretty simple:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ContiguousSubArray do
  def reverse_to_sort([num | t]) do
    reverse_to_sort(t, num, ReverseSortState.new(num))
  end

  def reverse_to_sort([num | t], prev, state) do
    IO.puts("#{inspect(state)}")

    case ReverseSortState.advance(state, num, prev) do
      false -&gt; false
      new_state -&gt; reverse_to_sort(t, num, new_state)
    end
  end

  def reverse_to_sort([], _, _state), do: true
end
</code></pre></div></div> <p>The ContiguousSubArray creates a new ReverseSortState and then calls into the function <code class="language-plaintext highlighter-rouge">reverse_to_sort/3</code>. In that function we call <code class="language-plaintext highlighter-rouge">ReverseSortState.advance/3</code> and pass the current state of our analysis of the input, the value in the array we’re currently on, and the previous value in the array. If the <code class="language-plaintext highlighter-rouge">advance</code> function returns a state then all is still good and we move forward one position by calling reverse_to_sort/3 recursively. If `advance’ returns false then the input didn’t meet our expectations and we return false to the caller. Our ReverseSortState is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ReverseSortState do
  defstruct [:max_subarray2, :max_subarray1, :status]

  def new(num) do
    %__MODULE__{
      max_subarray2: num,
      max_subarray1: nil,
      status: :leading_ascending
    }
  end

  def advance(%{status: status} = state, num, prev) when status == :leading_ascending do
    cond do
      num &gt; prev -&gt;
        %{state | max_subarray2: num, max_subarray1: prev}

      num == prev -&gt;
        false

      num &lt; prev and num_greater_than_max_subarray1?(state, num) -&gt;
        %{state | status: :descending}

      true -&gt;
        false
    end
  end

  def advance(%{status: status} = state, num, prev) when status == :descending do
    cond do
      num &lt; prev and num &lt; state.max_subarray2 and num_greater_than_max_subarray1?(state, num) -&gt;
        state

      num == prev -&gt;
        false

      num &gt; prev and num_greater_than_max_subarray1?(state, num) and num &gt; state.max_subarray2 -&gt;
        %{state | status: :trailing_ascending}

      true -&gt;
        false
    end
  end

  def advance(%{status: status} = state, num, prev) when status == :trailing_ascending do
    case num &gt; prev do
      true -&gt; state
      false -&gt; false
    end
  end

  defp num_greater_than_max_subarray1?(state, num) do
    is_nil(state.max_subarray1) or num &gt; state.max_subarray1
  end
end
</code></pre></div></div> <p>We can run this code thru some unit tests with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule ContiguousSubArrayTest do
  @inputs [
    {[-1, 5, 4, 3, 2, 8], true},
    {[1, 3, 2, 5, 4, 6], false},
    {[2, 3, 2, 4], false},
    {[19, 32, 23], true},
    {[5, 4, 3, 2, 1], true}
  ]

  def test do
    @inputs
    |&gt; Enum.map(fn {input, result} -&gt;
      ContiguousSubArray.reverse_to_sort(input) == result
    end)
  end
end
</code></pre></div></div> <p>On puzzles in general, there are a number of companies that use puzzles from these sites (or some developed internally) as filters for hiring. This is a bit frustrating if you are applying for a job working on what amounts to a CRUD app but are asked to solve puzzles that would never come up in the actual work for the job. But its not uncommon. If you know the company you’d like to work at will throw these type of puzzles at you then I’d recommend spending some time on one or more of the programming puzzle sites and work thru some puzzles. If you can find out which site the company uses then practice on that since each has their own UI and idiosyncrasies and you want to be familiar with it before you start working on puzzles as part of interview (ordinarily as a timed exercise).</p> <p>Sites to check out that have Elixir support:</p> <ul> <li><a href="https://codesignal.com/">https://codesignal.com/</a></li> <li><a href="https://exercism.io/">https://exercism.io/</a></li> </ul>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[Elixir puzzles]]></summary></entry><entry><title type="html">Elixir, Reading Dynamo Streams (Part 3)</title><link href="https://fmcgeough.github.io/blog/2019/dynamo-streams-3/" rel="alternate" type="text/html" title="Elixir, Reading Dynamo Streams (Part 3)"/><published>2019-10-23T08:53:13+00:00</published><updated>2019-10-23T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2019/dynamo-streams-3</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2019/dynamo-streams-3/"><![CDATA[<p>Finishing up this small project to read a DynamoDB stream with Elixir. The github repo for the project is: <a href="https://github.com/fmcgeough/dynamo_streamer">dynamo_streamer</a>. This post will cover generating random data to insert into the table and reading from the stream associated with the table.</p> <h2 id="writing-data">Writing Data</h2> <p>The module that represents the table data is simple (since the main purpose is just to show how to use the stream) :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule DynamoStreamer.UserActivity do
  @derive ExAws.Dynamo.Encodable

  alias DynamoStreamer.{Id, Table}

  defstruct [:id, :email, :activity, :ttl]

  def new(email, activity) do
    %__MODULE__{
      id: Id.generate(),
      ttl: DateTime.utc_now() |&gt; DateTime.add(3_600, :second) |&gt; DateTime.to_unix(),
      email: email,
      activity: activity
    }
  end
end
</code></pre></div></div> <p>This uses the @derive attribute. You can read more about this in the Elixir doc at <a href="https://elixir-lang.org/getting-started/protocols.html">Protocols</a>. The bottom line is that your struct will be converted into a map with decorations on it indicating the type. For example, lets suppose that I have a UserActivity struct that looks like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%DynamoStreamer.UserActivity{
  activity: %{page: "bGqh9Qqhhg29r3PdLtRp", task: "buying"},
  email: "PTnFGpDrQ8h66j9nff8g@gmail.com",
  id: "jLn22NHrRHBM9BfjgNtm",
  ttl: 1571842348
}
</code></pre></div></div> <p>When its encoded by the ex_aws_dynamo library for transmission to DynamoDB API it’ll look like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%{
  "activity" =&gt; %{
    "M" =&gt; %{
      "page" =&gt; %{"S" =&gt; "bGqh9Qqhhg29r3PdLtRp"},
      "task" =&gt; %{"S" =&gt; "buying"}
    }
  },
  "email" =&gt; %{"S" =&gt; "PTnFGpDrQ8h66j9nff8g@gmail.com"},
  "id" =&gt; %{"S" =&gt; "jLn22NHrRHBM9BfjgNtm"},
  "ttl" =&gt; %{"N" =&gt; "1571842348"}
}
</code></pre></div></div> <p>So, its still a map with your keys (as strings) at the top-most layer but the values now have those letters as keys in front of them. You can look thru the DynamoDB doc but in the example above: “M” = map, “S” = string, and “N” = number.</p> <p>An important thing to note is that data comes back to you from DynamoDB like that too. But I’m getting ahead of myself a bit. First, I’ll generate a random function in user_activity to generate some fake data and insert a few records into the table and make sure they are there.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def random do
    new("#{Id.generate()}@gmail.com", %{
      page: Id.generate(),
      task: Enum.random(["buying", "selling", "viewing", "data_entry"])
    })
  end
</code></pre></div></div> <p>Now insert a few records:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; alias DynamoStreamer.UserActivity
iex&gt; alias ExAws.Dynamo
iex&gt; 1..4 |&gt;
   Enum.each(fn _ -&gt; Dynamo.put_item("user-activities", UserActivity.random()) |&gt;
   ExAws.request()
   end)
</code></pre></div></div> <p>Now calling Dynamo.scan should return the 4 records</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iex&gt; Dynamo.scan("user-activities") |&gt; ExAws.request()
{:ok,
 %{
   "Count" =&gt; 4,
   "Items" =&gt; [
     %{
       "activity" =&gt; %{
         "M" =&gt; %{
           "page" =&gt; %{"S" =&gt; "hTg3Tt77mrPJ3MqBFTgp"},
           "task" =&gt; %{"S" =&gt; "buying"}
         }
       }
     },
     etc..
</code></pre></div></div> <p>As you can see the data is there in the “Items” value but its got all the DynamoDB signifiers in front on it and nobody would want to work with it that way. You can take the data and make it into a regular map in this way:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{:ok, %{"Items" =&gt; items}} = ExAws.Dynamo.scan("user-activities") |&gt; ExAws.request()
items |&gt; Enum.map(&amp;ExAws.Dynamo.Decoder.decode(&amp;1, as: DynamoStreamer.UserActivity))
</code></pre></div></div> <p>This yields values that look like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%DynamoStreamer.UserActivity{
    activity: %{"page" =&gt; "D7rJ8gjH26N98g7JJgjF", "task" =&gt; "data_entry"},
    email: "4pDmHmj9GhpjntT3m8qR@gmail.com",
    id: "fpqhngnn64ftdN3pjDgg",
    ttl: 1571843947
  }
</code></pre></div></div> <p>So, the <code class="language-plaintext highlighter-rouge">activity</code> is not decoded to atoms because its a map. If you wanted to do that you’d have to implement your own decode which will be called after the built in decoder is called.</p> <p>OK, so we’ve got records. Do we have streams? Well calling Dynamo.describe_table(“user-activities”) gives back a bunch of interesting info including “LatestStreamArn”. There’s some other interesting info in there so lets make a struct that encapsulates that.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule DynamoStreamer.StreamInfo do
  defstruct [:stream_arn, :stream_label, :enabled, :view_type]

  @type t :: %__MODULE__{
          stream_arn: binary | nil,
          stream_label: binary | nil,
          enabled: boolean | nil,
          view_type: binary | nil
        }

  def new(%{
        "Table" =&gt; %{
          "LatestStreamArn" =&gt; stream_arn,
          "LatestStreamLabel" =&gt; stream_label,
          "StreamSpecification" =&gt; %{
            "StreamEnabled" =&gt; enabled,
            "StreamViewType" =&gt; view_type
          }
        }
      }) do
    %__MODULE__{
      stream_arn: stream_arn,
      stream_label: stream_label,
      enabled: enabled,
      view_type: view_type
    }
  end

  def new(_), do: {:error, "Unexpected format"}
end
</code></pre></div></div> <p>As it turns out, we need the stream_arn for a couple of things. We use it for listing shards using the describe_stream function and we need it to get a shard iterator which we need to get the records themselves.</p> <p>I’ve put together all the pieces and pushed it up to github. There are lots of other details that you’d need to work out in order to use in a real application but hopefully it helps get you started if you’re just curious about how DynamoDB works with Elixir.</p>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[How to read from Dynamo stream in Elixir]]></summary></entry><entry><title type="html">Elixir, Reading Dynamo Streams (Part 2)</title><link href="https://fmcgeough.github.io/blog/2019/dynamo-streams-2/" rel="alternate" type="text/html" title="Elixir, Reading Dynamo Streams (Part 2)"/><published>2019-10-22T08:53:13+00:00</published><updated>2019-10-22T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2019/dynamo-streams-2</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2019/dynamo-streams-2/"><![CDATA[<p>Just made a small change to this project today since I didn’t have a lot of time to work on it and got involved in looking at Clojure. The project now has some of the standard dependencies you regularly see in “real” Elixir project: excoveralls, dialyxer, credo, ex_doc. And I’ve refactored table.ex to be more general purpose and moved the creation of the actual test table for this project to user_activity.ex.</p> <p>There is a couple of unit tests now just to show an approach to mocking requests with ExAws. Its obviously not necessary for this test project but it seemed like something someone coming to Elixir and stumbling on these posts might like to see. In any case, everything is available at <a href="https://github.com/fmcgeough/dynamo_streamer">dynamo_streamer</a> and I’m tagging the work I’m doing. This particular increment is v0.3. :-)</p> <p>Hopefully tomorrow there will be records into DynamoDB and the beginning of dealing with streams, shards and iterators.</p>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[How to read from Dynamo stream in Elixir]]></summary></entry><entry><title type="html">Elixir, Reading Dynamo Streams and Layoffs</title><link href="https://fmcgeough.github.io/blog/2019/reading-dynamo-streams/" rel="alternate" type="text/html" title="Elixir, Reading Dynamo Streams and Layoffs"/><published>2019-10-20T08:53:13+00:00</published><updated>2019-10-20T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2019/reading-dynamo-streams</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2019/reading-dynamo-streams/"><![CDATA[<p>I was working remotely for Weedmaps up until recently writing Elixir with a group of really great coworkers. Unfortunately, Weedmaps laid off 25% of its workforce and I was let go, along with some other really great productive people - if you need devs, qa, project managers please ask me. I know a bunch that I really enjoyed working with. I figured while I search for a new position I’d use some of the time to blog a bit about Elixir. This will be a bit rambling since I’m writing in-between phone calls and interviews.</p> <p>Elixir is a relatively young language but has a great community of developers that contribute some very useful code. One of the reliable libraries that I’ve used multiple times is: <a href="https://github.com/ex-aws/ex_aws">ex_aws</a>.</p> <p>This library provides base services for AWS API’s. If you’ve used Python for AWS via the Boto library you can think of ex_aws as providing similar functionality. However, the approach the library developer took was to separate the base functionality (XML and JSON request building, exponential backoff) from the service libraries that provide an actual interface to an API service. I really like this approach for wrappers around the AWS APIs because I don’t want to have code for every single service that AWS provides in my app. Being able to just setup dependencies I need means that I probably will be able to look at every piece of code and evaluate any security problems or issues that might impact upgrades in the future.</p> <h2 id="dynamodb">DynamoDB</h2> <p>AWS provides a key-value store called DynamoDB. Its got several nice features that make it a popular choice for companies using AWS. Its self-managed and can scale based on usage patterns, for example. One of its other nice features is that there is a stream API that gives you access to changes that have been made over the last 24 hours. For this blog post I’ll build a little github repo that demonstrates that stream API.</p> <p>Another nice feature of DynamoDB is that you can use docker to run a local copy of DynamoDB. I’m a big fan of this. If only all the AWS services provided some means of development and testing without using AWS itself. In any case, it’ll allow you to download the repo I build in github and try it out without even having an AWS account. Here’s the docker commands you can use to get a local DynamoDB running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull amazon/dynamodb-local
docker run -p 8000:8000 amazon/dynamodb-local
</code></pre></div></div> <p>There are two separate libraries that plug into ex_aws for DynamoDB: 1) ex_aws_dynamo that covers the API to access to your table and 2) ex_aws_dynamo_streams that covers the separate API for the streams functionality. Since I want to demonstrate how to use the stream API I’ll need the base API in order to create a table that provides stream data and insert records that show up in the stream. The project is in github at: <code class="language-plaintext highlighter-rouge">https://github.com/fmcgeough/dynamo_streamer</code></p> <h2 id="creating-a-simple-elixir-project">Creating a Simple Elixir project</h2> <p>Mix is the ubiquitous command line tool for Elixir. I’ve talked to a number of Rails developers that liked this approach (as opposed to bundle, rails, rake, etc). In any case if you’re new to Elixir it’d be good to spend some time becoming familiar with all that mix offers. Here’s what I used to create a new bare-bones Elixir project.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix new dynamo_streamer
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating config
* creating config/config.exs
* creating lib
* creating lib/dynamo_streamer.ex
* creating test
* creating test/test_helper.exs
* creating test/dynamo_streamer_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

  cd dynamo_streamer
  mix test

Run "mix help" for more commands.
</code></pre></div></div> <p>The main configuration file for every Elixir project is the mix.exs file. This is where I’ll add the dependencies for the 2 dynamo libraries. You can learn the syntax needed for a particular library by visiting <a href="https://hex.pm/">hex.pm</a> which is the package manager for the Erlang ecosystem.</p> <p>We’ll add the 2 dynamo libraries as dependencies in mix.exs (they are both dependent upon ex_aws). Open up the config file in the deps/ex_aws_dynamo_streams/config/config.exs and you’ll see the config that is necessary in order to use the local DynamoDB. Trim down the README to something really basic and I’ll push that all to github at: <code class="language-plaintext highlighter-rouge">https://github.com/fmcgeough/dynamo_streamer</code>. I’ll add tags along the way and do pull requests so it’ll hopefully be easy to follow the steps if you want to.</p> <h2 id="but-the-libraries-wont-help-you-understand">But the Libraries Won’t Help you Understand</h2> <p>The thing about the wrapper libraries that plug into ex_aws is that for the most part they have very bare-bones documentation (sometimes none). In any case, when you are using a new AWS service via Elixir you’ll need to open up the AWS doc page.</p> <ul> <li><a href="https://docs.aws.amazon.com/en_pv/amazondynamodb/latest/APIReference/API_Operations_Amazon_DynamoDB.html">DynamoDB API Doc</a></li> <li><a href="https://docs.aws.amazon.com/en_pv/amazondynamodb/latest/APIReference/API_Operations_Amazon_DynamoDB_Streams.html">DynamoDBStreams API Doc</a></li> </ul> <h2 id="creating-a-dynamodb-table">Creating a DynamoDB Table</h2> <p>OK, so in order to use DynamoDB Streams we need a table created that enables streams. I’ll create a new local branch:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout -b create_table
</code></pre></div></div> <p>Some bookkeeping first. Lets delete the files : lib/dynamo_streamer.ex and test/dynamo_streamer_test.exs. Those were generated as templates by the mix new and we won’t need them. Now I’ll create a file called lib/table.ex to hold the code related to creating and setting up our table.</p> <p>When you decide to use an Elixir library you need to examine its doc as well.</p> <ul> <li><a href="https://hexdocs.pm/ex_aws_dynamo/ExAws.Dynamo.html">ex_aws_dynamo Doc</a></li> <li><a href="https://hexdocs.pm/ex_aws_dynamo_streams/ExAws.DynamoStreams.html">ex_aws_dynamo_streams Doc</a></li> </ul> <p>Another issue. If you try to use just these libraries by themselves it won’t work. You’ll need two other libraries: hackney and poison. Hackney is used to send the web requests and poison is used to decode responses.</p> <p>OK, so that’s sorted. What kind of table do I want to create in Dynamo? Well for this little demo I’ll create a table called “user-activities” that tracks actions by users in our UI over the last hour. I’ll remove the rows from the table after one hour using Dynamo’s TTL. These removed rows show up in the stream so it’ll allow me to write code that differentiates between rows that were inserted and rows that were removed by the TTL.</p> <p>When you create a Dynamo table you’ll have to decide on its partition key as well. Since we’re only interested in using this as a demonstration on how to read from DynamoDB Streams we’ll use a generated id. This partition key is defined as a HASH key. You can also specify a sort key. We’ll use email as the sort key. The sort key is defined as a RANGE key. You can only have one of each for your DynamoDB table. The function ends up looking like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def create_table(tablename) do
    tablename
    |&gt; Dynamo.create_table(
      [id: :hash, email: :range],
      [id: :string, email: :string],
      1,
      1
    )
    |&gt; ExAws.request()
  end
</code></pre></div></div> <p>For the table definition itself we can define a module with a struct that ex_aws_dynamo will encode. For the id generation, I pulled in the <a href="https://hexdocs.pm/puid/Puid.html">puid library</a>.</p> <p>Our simple table definition is simply:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule DynamoStreamer.UserActivity do
  @derive ExAws.Dynamo.Encodable

  alias DynamoStreamer.Id

  defstruct [:id, :email, :activity, :ttl]

  def new(email, activity) do
    %__MODULE__{
      id: Id.generate(),
      ttl: DateTime.utc_now() |&gt; DateTime.add(3_600, :second) |&gt; DateTime.to_unix(),
      email: email,
      activity: activity
    }
  end
end
</code></pre></div></div> <h2 id="adding-supervision-and-wrapping-up">Adding Supervision and Wrapping up</h2> <p>Finally, when the project was generated we didn’t use the <code class="language-plaintext highlighter-rouge">--sup</code> option to get a supervisor. I feel like I’ll need it to generate data and read from the stream independently. Its easy enough to add after the fact. I’ll modify the applications section of the mix.exs so that we start a DynamoStreamer.Application on startup. You can read about that by using <code class="language-plaintext highlighter-rouge">mix help compile.app</code>.</p> <p>So, that gives us some of the base things in place. Next stop is to start generating some data to populate our table and stream. I’ll hopefully tackle that tomorrow.</p>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[How to read from Dynamo stream in Elixir]]></summary></entry><entry><title type="html">ElixirConf2016 and Ecto</title><link href="https://fmcgeough.github.io/blog/2019/14-00-00-elixirecto/" rel="alternate" type="text/html" title="ElixirConf2016 and Ecto"/><published>2019-09-03T08:53:13+00:00</published><updated>2019-09-03T08:53:13+00:00</updated><id>https://fmcgeough.github.io/blog/2019/14:00:00-elixirecto</id><content type="html" xml:base="https://fmcgeough.github.io/blog/2019/14-00-00-elixirecto/"><![CDATA[<p>Just got back from ElixirConf2016. It was an awesome experience even with how wet Disney World was from the side effects of Hurricane Hermine. Very interesting sessions and a lot of excitement. Also seemed like a really nice community. Lots of folks coming from Rails. A couple people from Java.</p> <p>There were 542 attendees and that was basically doubled from last year’s conference. A large number of people already had Elixir/Phoenix code in production - which was encouraging. I was there more as a tourist than anything. Trying to figure out if this is something that I should really try and dig into or just something to play around with. I think by the end of the conference I thought that this was something that has a real chance to be a solid development community over the next decade.</p> <p>I enjoyed every talk that I went to but the one by Darin Wilson (@darinwilson) on Ecto was immediately useful and something that I was able to quickly wrap my head around with my database background. Ecto is Elixir’s database wrapper. It’s relatively new - like most of Elixir - but its really well thought out and usable.</p> <p>Darin’s talk and sample project (a music db) covered a lot of Ecto use cases, including :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    belongs_to :artist, Artist
    has_many :tracks, Track
    many_to_many :genres, Genre, join_through: "albums_genres"
</code></pre></div></div> <p>Its worth checking out if you are new to Ecto. Its in github at <a href="https://github.com/darinwilson/music_db">music_db github repo</a>.</p> <p>The actual database access is provided by an Adapter that implements a set of callbacks and a driver that implements the database communication protocol (it appears - I’m still learning this myself). The default relational database is Postgres (good choice!).</p> <p>Ecto just released version 2.0 and the only Adapter that appears to work at this point is Postgres. MySQL and MongoDB were supported &lt; 2.0 so hopefully support for them is added back shortly.</p> <p>The preferred syntax to form queries is key-word based. This should work well for standard database models. Again, there are decent examples in Darin’s sample project.</p> <p>Will be spending a few hours trying to wrap my head around using Ecto for a work model of Users, Roles, Accounts, etc.</p>]]></content><author><name></name></author><category term="Elixir"/><category term="Elixir"/><summary type="html"><![CDATA[Review of Elixir Config 2016]]></summary></entry></feed>